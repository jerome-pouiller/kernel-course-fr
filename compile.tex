%
% This document is available under the Creative Commons Attribution-ShareAlike
% License; additional terms may apply. See
%   * http://creativecommons.org/licenses/by-sa/3.0/
%   * http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
% Created: 2012-03-13 00:08:25+01:00
% Main authors:
%     - Jérôme Pouiller <jezz@sysmic.org>
%

\part{Compiler}

\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \tableofcontents
\end{frame}

\section{Les BSP}

\begin{frame}[fragile=singleslide]{Qu'est-ce qu'un BSP?}
  \begin{itemize} 
  \item \emph{Board Support Package (BSP)}
  \item Normalement fourni par l'intégrateur.
  \item  Contient  au   minimum  la  toolchain  (compilateur,  linker,
    debuggueur) pour la cible, au  minimum les sources, et souvent des
    versions pré-compilées
  \item  Cette toolchain est  souvent compilée  avec une  libc (glibc,
    µclibc, newlib,  bionic, eglibc,  dietlibc, klibc, etc...)  et une
    version des binutils. Si ça n'est pas le cas, elle pourra compiler
    le noyau Linux, mais aucune binaire utilisateur.
  \item  Contient souvent  le  bootloader (sources  et/ou binaire)  le
    noyau  Linux  (au minimum  les  sources,  et  parfois une  version
    pré-compilée).
  \item Si la  cible possède des drivers spécifique  externes à Linux,
    ils doivent (devraient) être fournis avec la toolchain.
  \item  De même,  si la  cible doit  utiliser  certaine bibliothèques
    spécifiques, elle sont normalement fournies
  \item Contient la documentation (parfois incomplète...)
  \item Assez souvent, un \emph{rootfs} est fourni
  \end{itemize} 
  \note{A intégrer dans embeded_linux}
\end{frame} 

\section{Obtenir le noyau}

\subsection{Télécharger les sources}

\begin{frame}[fragile=singleslide]{Récupération des sources}
  Ou récupérer les sources du originales noyau?
  \begin{itemize} 
  \item Utiliser les sources souvent  fournies avec le BSP.  Il arrive
    souvent qu'elles contiennent  des drivers particuliers et qu'elles
    soient déjà configurées
  \item Télécharger sur \file{kernel.org}
    \begin{lstlisting}[language=sh]
host$ wget http://www.kernel.org/pub/linux/kernel/v3.x/linux-3.3.tar.bz2
host$ tar xvjf linux-3.3.tar.bz2
    \end{lstlisting}
  \item Utiliser \cmd{git clone}
  \end{itemize} 
\end{frame} 

\subsection{Comprendre le versionning}

\begin{frame}[fragile=singleslide]{Versionning}
  \begin{itemize}
  \item Au début, le noyau s'incrémentait de deux en deux: 2.0, 2.2, 2.4,
    etc... Les version impaires indiquait les noyau en développement.
  \item  Chaque version  du noyau  apportait des  ruptures importantes
    avec la version précédente
  \item Avec le noyau 2.5 puis 2.6, le noyau est arrivé à une certaine
    maturité.   Les  gros  changements   sont  devenus  rares  et  les
    développements sont devenus de plus en plus itératifs
  \item Finalement  dans la version 2.6, toutes  les versions mineures
    sont stables
  \item Les versions stables de la 2.6 peuvent recevoir des correctifs
    et sont alors numérotés sur 4 chiffres: (exemple: 2.6.32.59)
  \item  Le  développement d'une  nouvelle  version  du  noyau 2.6  en
    intégrant  les  patchs provenant  des  sous-systèmes.  Les  noyaux
    produit  lors de  l'intégration  de ses  patchs  est suffixés  par
    \texttt{rcX} (\emph{release candidate}).
  \item Le  développement noyau  alterne les fenêtres  de \emph{merge}
    pendant lesquels, les mainteneurs des sous-systèmes envoient leurs
    développements à Linus Torvalds et fenêtres de stabilisation.
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Versionning}
  \begin{itemize}
  \item La version 3.0 correspond en fait la version 2.6.40 renommée:
    \begin{itemize}
    \item  Il n'y  a eu  aucune  refonte de  l'architecture entre  les
      version 2.6 et 3
    \item Pour fêter les 20ans du kernel
    \item Pour marquer l'intégration  de la branche RT-Preempt dans le
      mainstream
    \item  Parce  qu'avec  le  cycle de  développement  itératif,  la
      version 2.6 ne s'incrémentera jamais. Les version stable quant à
      elles  peuvent recevoir  des  correctif et  se  retrouver sur  4
      chiffres.  Il y  avait par  conséquent un  chiffres en  trop. Le
      passage en 3.Y.Z permettait de revenir sur un modèle classique à
      3 chiffres.
    \item Le passage en 3.X marque ainssi la stabilisation du cycle de
      développement du noyau
    \end{itemize} 
  \item Référence : \file{Documentation/development-process}
  \end{itemize} 
\end{frame} 

\subsection{Utiliser Git}

\begin{frame}[fragile=singleslide]{Git}
  \begin{itemize} 
  \item \cmd{git} est l'outil de gestion de sources du noyau
  \item Il  est fortement recommander  de l'utiliser dans le  cadre du
    développement du noyau
  \item Il s'agit d'un système de gestion décentralisé. 
  \item Pour expliquer la décentralisation, imaginez que:
    \begin{itemize} 
    \item Un utilisateur duplique un dépôt svn
    \item Des modifications sont apportées sur les deux dépôts
    \item On essaye de resynchronisez les deux dépôts...
    \end{itemize}
  \item  Considérez  git  comme   un  svn  capable  d'effectuer  cette
    opération très simplement.
  \item Lorsqu'un utilisateur récupère  le code d'un dépôt, il devient
    lui-même dépôt
  \item Si l'utilisateur laisse un moyen quelconque d'accès en lecture
    à son dépôt, d'autres personnes  pourrons à leur tour le cloner ou
    tirer les modification qu'il a effectué
  \item  \url{http://git.kernel.org} liste  les  dépôts publiques  des
    principaux développeurs du noyau
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Git}
  \begin{itemize} 
  \item Pour récupérer un dépôt:
    \begin{lstlisting}
git clone <depôt>
    \end{lstlisting} 
  \item Quelques dépôts notables:
    \begin{itemize} 
    \item
      \url{git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git}
      Le dépôt de  Linus Torvalds. Il contient les  derniers patchs du
      noyau en développement
    \item
      \url{git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git}
      Le dépôt  stable. Contient la dernière version  stable du noyau,
      ainsi les mises à jours des versions stables
    \item
      \url{git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git}
      Les  dépôt une  dizaine de  sous-projets importants  sont mergés
      automatiquement dans  ce dépôt.  Utilisé  principalement par des
      robots  afin d'identifier les  problèmes de  merge en  amont des
      phases d'intégrations
    \item
      \url{git://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git}
      L'historique des versions entre 2.5.0 et 2.6.12.
    \end{itemize} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Git}
  Récupérons la version stable
  \begin{lstlisting}[language=sh]
host$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
  \end{lstlisting} 
  Chaque version du noyau est marquée avec un tag
  \begin{lstlisting} 
host$ git tag
  \end{lstlisting} 
  Puis il est possible de récupérer une version avec
  \begin{lstlisting}
host$ git checkout v3.3
  \end{lstlisting}
  Votre dépôt est alors  non-modifiable.  Vous devez créer une branche
  de travail:
  \begin{lstlisting}
host$ git checkout -b mybranch v3.3
  \end{lstlisting}
\end{frame}

\section{Organisation des sources}

\begin{frame}[fragile=singleslide]{Organisation des sources}
  On remarque qu'il existent d'énorme différences de tailles entre les
  répertoires:
  \begin{lstlisting}[language=sh]
$ du -s */ | sort -n | column
40      usr              4092    scripts
156     samples          5248    kernel
160     init             6436    firmware
180     virt             19524   Documentation
232     ipc              21332   net
884     block            22728   include
1904    crypto           24016   sound
1932    lib              32436   fs
2076    security         121584  arch
2400    mm               252688  drivers
3536    tools
  \end{lstlisting} 
\end{frame}

\subsection{Les sous-répertoires de la racine}

\begin{frame}[fragile=singleslide]{Organisation des sources}
  \begin{itemize} 
  \item Les services indispensables à un OS:
    \begin{itemize} 
    \item  \file{kernel} Le  scheduler  de tâches,  les frameworks  de
      gestion  des   IRQ,  le  loader  de   binaires,  diverses  autre
      fonctionnalités ne rentrant dans aucune autre catégories.
    \item  \file{mm} Le  gestionnaire de  mémoire. Considéré  comme la
      partie la plus complexe du noyau
    \item   \file{init}   La    fonction   de   démarrage   du   noyau
      (\c{start_kernel}).
    \item  \file{arch} Le  code spécifique  à chaque  architecture. En
      particulier,  le code nécessaire  au boot,  à la  génération des
      images,   les   routine   assembleur   pour   la   gestion   des
      interruptions, etc...
      % \item \file{init} Le \emph{bootloader} du noyau. Petit morceau
      %   de  code  capable  de  décompresser  le noyau  avant  de  le
      %   démarrer (\c{start_kernel}).
    \item  On peut  estimer que  l'intelligence  réside principalement
      dans \file{kernel}  et \file{mm}.  On remarque cette  partie est
      finalement relativement petite dans le noyau.
    \end{itemize} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Organisation des sources}
  \begin{itemize} 
  \item Les services supplémentaires du noyau:
    \begin{itemize}
    \item \file{fs} Les systèmes de fichiers: ext3, NTFS, NFS, etc...
    \item \file{net} La gestion  du réseau et plus particulièrement la
      stack IP
    \item  \file{ipc}  La  gestion  des  communication  inter-processus
      (shmem, mq, etc..)
    \item  \file{security} Les  frameworks  de gestion  de la  sécurité
      (selinux, apparmor,  etc..)  
    \end{itemize} 
  \end{itemize}  
\end{frame}

\begin{frame}[fragile=singleslide]{Organisation des sources}
  \begin{itemize} 
  \item Les drivers
    \begin{itemize} 
    \item  \file{drivers/*} Tous  les autres  drivers et  frameworks de
      développements. De loin la plus grosse partie du code du noyau.
    \item \file{sound} Les drivers de cartes son.
    \item \file{firmware}  Certains périphériques nécessitent l'upload
      d'un firmware  pour s'initialiser. \file{firmware}  contient les
      binaires de  ces firmwares (sans  les sources!). La  politique de
      Linux  au sujet du  code de  ces firmwares  est qu'il  s'agit de
      données  d'initialisation  de   ces  périphériques  et  que  par
      conséquent, ils ont leurs place dans l'arborescence du noyau.
    \item \file{block} Le framework des périphériques de \emph{block}.
    \item \file{virt/kvm} Le framework de virtualisation kvm.
    \end{itemize} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Organisation des sources}
  \begin{itemize} 
  \item Des bibliothèques utilitaires:
    \begin{itemize} 
    \item \file{lib} Divers utilitaires
    \item   \file{crypto}  Fonctions   utilitaires   relatives  à   la
      cryptographie
    \end{itemize} 
  \item Le code annexe:
    \begin{itemize} 
    \item \file{include} Les headers exposés du noyau.
    \item  \file{scripts} Les  scripts ou  les  programmes utilitaires
      nécessaires à la compilation ou à l'exploitation du noyau
    \item   \file{usr}   Script  nécessaire   à   la  génération   des
      \emph{initramfs}
    \item  \file{tools}  Les  outils  permettant la  communication  de
      certains frameworks avec le noyau (particulièrement \c{perf})
    \end{itemize} 
  \item La documentation
    \begin{itemize} 
    \item \file{Documentation} La documentation
    \item \file{sample} Des exemples de code pour certains frameworks
    \end{itemize} 
  \end{itemize} 
\end{frame} 
% Cohérence: 
%   sound -> drivers/sound
%   block -> drivers
%   virt alors que xen se trouver dans drivers
%   usr, tools et scripts redondant
%   Pourquoi Documentation prend un D majuscule?

\subsection{Le répertoire \texttt{arch/}}

\begin{frame}[fragile=singleslide]{Les architectures}
  Regardons \file{arch/} de plus près:
  \begin{itemize} 
  \item Les PC: \file{x86}
  \item Les  workstations et les  serveurs: \file{alpha}, \file{sparc}
    (Sun),    \file{ia64}    (Intel),   \file{powerpc},    \file{s390}
    (Mainframes d'IBM) \file{parisc} (Workstation HP)
  \item     L'embarqué:     \file{arm},     \file{mips},     \file{sh}
    (STMicroelectronics),   \file{avr32},  \file{m68k},  \file{score},
    \file{mn10300}, \file{m32r} \file{h8300}
  \item  Les architectures  dédiées:  \file{cris} (Embedded  Network),
    \file{frv} (Futjisu, Traitement d'image)
  \item  Les   DSP:  \file{c6x}  (Texas   Instrument),  \file{heaxgon}
    (Qualcomm), \file{blackfin}
  \item Les softcores: \file{microbaze}, \file{xtensa}
  \item  Les   expérimentaux  \file{tile}  (Architecture  distribuée),
    \file{unicore32} (Université de Pekin), \file{openrisc}
  \item User Mode Linux: \file{um}
  \end{itemize} 
  On retrouve nos 26 (+1) architectures supportées
\end{frame}    

\begin{frame}[fragile=singleslide]{Le code spécifiques aux architectures}
  \begin{itemize} 
  \item On retrouve dans  les sous-répertoire de \file{arch/} certains
    répertoires de la racine.
  \item  \file{mach-}, \file{plat-}, \file{plateforms}  contiennent du
    code spécifique  à un  type de plateformes:  Ti Omap,  Atmel AT91,
    PowerPC 85xx
  \item    On   pourra   trouver    des   fichiers    spécifique   aux
    \emph{board}.  Particulièrement vrai  pour  les architectures  non
    plug-and-play qui nécessite  que les périphériques soient déclarés
    manuellement
  \item   \file{include/}   contient   des   headers   spécifiques   à
    l'architecture. Lors  de la  compilation, un lien  symbolique sera
    créé         entre        \file{arch/<ARCH>/include/asm}        et
    \file{include/asm}. Ce  lien permet au noyau de  s'abstraire de la
    plateforme
  \item \file{boot/}  contient le code  nécessaire au démarrage  de la
    cible:
    \begin{itemize}
    \item  Le  code  du  \emph{bootloader}  et  les  scripts  associés
      permettant la décompression du noyau en mémoire
    \item Les scripts nécessaire à la génération d'une image au format
      du bootloader, du flasher ou de la sonde JTAG
    \end{itemize} 
  \end{itemize} 
\end{frame} 

\section{Compiler le noyau}

\subsection{Le système de compilation du noyau}

\begin{frame}[fragile=singleslide]{Fonctionnement de Kconfig}
  \begin{itemize}
  \item Système de compilation du noyau
  \item Application de la règle: ``Pas générique mais simple à hacker''
  \item Dépend principalement de \cmd{gmake}
  \item  Pas un  système de  compilation réel. Composé de :
    \begin{itemize}
    \item Kconfig: Système de gestion de configuration
    \item Kbuild: Ensemble de règles de Makefile bien pensées
    \end{itemize}
  \item  Adapté  aux environnements  proposant  beaucoup d'options  de
    configuration
  \item Très bien adapté à la cross-compilation
  \item Utilisé dans d'autre projets: µclibc, busybox, buildroot (tous
    dans le milieu de l'embarqué)
\end{itemize}
\end{frame} 

\begin{frame}[fragile=singleslide]{Le système de compilation}
\begin{itemize} 
  \item Pour obtenir de l'aide sur les différentes cibles:
    \begin{lstlisting}
host$ make help
    \end{lstlisting} 
  \item  La   variable  \c{ARCH=}  spécifie   l'architecture  cible  à
    utiliser.   Elle   impacte  les   options   du  noyau.    Comparez
    \cmd{make help} avec \cmd{make ARCH=arm help}.
  \item   Si   \c{ARCH}   n'est   pas   spécifiée,   Kconfig   utilise
    l'architecture \emph{host}.
  \item Lorsque  vous avez commencé  à spécifier \c{ARCH},  vous devez
    toujours la  spécifier. 
  \item Il  est toutefois  possible de placer  cette variable  dans le
    Makefile racine ou dans l'environnement pour éviter de l'oublier.
    \begin{lstlisting}
host$ export ARCH=arm 
    \end{lstlisting} 
  \end{itemize} 
\end{frame} 

\subsection{Gérer les configurations}

\begin{frame}[fragile=singleslide]{Travailler avec les configurations}
  \begin{itemize} 
  \item \c{make  help} propose des configurations  préétablies. Il est
    possible d'importer une de ces configuration:
    \begin{lstlisting} 
host$ make ARCH=arm usb-a9260_defconfig
    \end{lstlisting} 
  \item Kconfig sauvegarde la configuration dans \file{.config}. 
  \item Le fichier \file{.config} sera ensuite:
    \begin{itemize} 
    \item Sourcé dans les systèmes de Makefile
    \item Transformé  en \file{include/generated/autoconf.h} et inclut
      dans les headers de compilations
    \end{itemize} 
  \item Certains  constructeur vous  fournirons un patch  ajoutant une
    cible \c{_defconfig}
  \item ... d'autres vous fournirons un \file{.config}
\end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Travailler avec les configurations}
  \begin{itemize} 
  \item  Lorsque  votre   fichier  \file{.config}  n'est  parfaitement
    compatible  avec vos sources  (import, mise  à jours  des sources,
    édition manuelle, ...), il recommandé (nécessaire?) de lancer
    \begin{lstlisting} 
host$ make oldconfig
    \end{lstlisting} 
    \c{oldconfig}  vous  indique  d'éventuelles incompatibilité  entre
    votre configuration et vos sources  et vous demande votre avis sur
    les nouvelles options
  \item Pour répondre systématiquement avec la réponse par défaut:
    \begin{lstlisting} 
host$ yes "" | make oldconfig
    \end{lstlisting} 
  \item Obtenir  la liste  des nouvelles options  par rapport  à votre
    configuration:
   \begin{lstlisting} 
host$ make listnewconfig
   \end{lstlisting} 
 \item Vous  pouvez normalement trouver  la configuration du  noyau de
   votre \emph{host} dans \c{/boot/config-`uname -r`}
 \item Sauver votre configuration en effectuant un \emph{sanity check}
   \begin{lstlisting}  
host$ make savedefconfig
   \end{lstlisting} 
  \item Référence: \file{Documentation/kbuild/kconfig.txt}
 \end{itemize}
\end{frame} 

\subsection{Modifier les configurations}

\begin{frame}[fragile=singleslide]{Configurer le noyau}
 Pour configurer les options:
 \begin{itemize}    
 \item En ligne de commande (inutilisable pour un humain)
   \begin{lstlisting}
host$ make config
   \end{lstlisting} %$
 \item En ncurses
   \begin{lstlisting}
host% apt-get install libncurses5-dev
host$ make menuconfig
   \end{lstlisting} %$
 \item Avec la nouvelle version de ncurses 
   \begin{lstlisting}
host% apt-get install libncurses5-dev
host$ make nconfig
   \end{lstlisting} %$
\end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Configurer le noyau}
\begin{itemize} 
 \item En Qt4
   \begin{lstlisting}
host% apt-get install libqt4-dev
host$ make xconfig
   \end{lstlisting} %$
 \item En Gtk
   \begin{lstlisting}
host% apt-get install libglade2-dev
host$ make gconfig
   \end{lstlisting} %$
 \item Dans  toutes les  interfaces, il est  possible d'obtenir  de la
   description sur l'élément sélectionné (\c{<h>} ou \c{<?>})
 \item  Il  est  possible  de  rechercher dans  les  descriptions  des
   éléments (\c{</>})
 \item  Dans   la  recherche  et  dans  l'aide,   vous  trouverez  des
   informations sur les dépendances entre les options
 \item   Les  script  \cmd{scripts/config}   permet  de   changer  les
   configuration à la main
 \end{itemize}
\end{frame}

\subsection{Compiler}

\begin{frame}[fragile=singleslide]{Les cibles de compilation}
  \begin{itemize} 
  \item  La compilation  du noyau  se lance  juste avec 
    \begin{lstlisting} 
host$ make
    \end{lstlisting} 
  \item Le  système choisi les  cible appropriée en fonction  de votre
    architecture (principalement, une image et les modules)
   \item Il est souvent  préférable (nécessaire?) de spécifier le type
     d'image voulue avec
    \begin{lstlisting}
host$ make XXImage
    \end{lstlisting}
  \item \texttt{XX} fait référence au format de la binaire produite:
    \begin{itemize}
    \item Le code commence=t=il au premier octet?
    \item Respecte-t-il le format ELF?
    \item Y a-t-il un format particulier d'entête à respecter ?
    \end{itemize}
  \item Dans  le doute,  il faut consulter  la documentation  de votre
    bootloader
  \end{itemize}
\end{frame} 

\subsection{Options de Kbuild}

\begin{frame}[fragile=singleslide]{Options de Kbuild}
  Certaines options peuvent être passées sur la ligne de commande afin
  de modifier le comportement général du système.
  \begin{itemize}
  \item  \c{ARCH=} spécifie l'architecture  à utiliser.  (Nous l'avons
    déjà vu)
  \item \c{CROSS_COMPILE=} spécifie le préfixe de la toolchain. Ainsi,
    si vous  compilez avec \cmd{/opt/arm/usr/bin/arm-linux-ulibc-gcc},
    vous                        devez                       spécifier:
    \c{CROSS_COMPILE=/opt/arm/usr/bin/arm-linux-ulibc-}.            Par
    commodité,  on  préférera   ajouter  \cmd{/opt/arm/usr/bin}  à  la
    variable  d'environnement  \cmd{PATH}.  Il  est aussi  possible  de
    configurer \c{CROSS_COMPILE} par Kconfig
    \note[item]{Parler de vared et de PATH+=:/path}
  \item \c{V=1} permet d'afficher les commandes lancées par le système
    de  compilation plutôt que  la version  abrégée. Pas  très lisible
    lors   des  compilations   parallèles   mais  indispensable   pour
    comprendre certaines erreurs de compilation
  \item De base, le noyau n'active que les warnings utiles (ainsi, les
    warnings  produits sont rarement  à ignorer).   \c{W=[123]} permet
    d'activer des warnings supplémentaires
\end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Options de Kmake}
  \begin{itemize} 
  \item  \c{C=\{1,2\}} lance l'outil  sparse sur  les sources.  Nous y
    reviendrons.
  \item  \c{-jX} est  une option  de \cmd{make}  qui permet  de lancer
    \c{X}  compilation simultanées.  Grosso  modo, \c{X}  devrait être
    plus ou moins votre nombre de coeurs CPU.
  \item \c{O=} permet de compiler \emph{out-of-source}:
    \begin{lstlisting}
host$ mkdir build
host$ make ARCH=arm CROSS_COMPILE=arm-linux- O=build menuconfig
    \end{lstlisting} %$
    Tous  les  fichier  issus  de  la génération  seront  placés  dans
    \file{build}.  Une fois  que  votre configuration  est crée,  vous
    pouvez lancer \cmd{make} directement  à partir de \file{build}. La
    compilation  \emph{out-of-source} permet  une grande  souplesse de
    développement et est fortement recommandée.
  \item Référence: \file{Documentation/kbuild/kbuild.txt}
  \end{itemize} 
\end{frame}

\subsection{Résultats de la compilation}

\begin{frame}[fragile=singleslide]{Résultats de la compilation}
  Fichiers produits (ou productibles) par la compilation:
  \begin{itemize}
  \item  \verb+vmlinux+:  L'image  ELF  du  noyau.   Lisible  par  les
    debugueurs, certains flasheurs, certain bootloaders
  \item  \verb+vmlinuz+: parfois  équivalent  du \verb+bzImage+,  mais
    normalement, il  s'agit de\verb+vmlinux+ compressé  et strippé des
    informations inutiles  au démarrage. Inutilisable  dans l'état, il
    est nécessaire de lui adjoindre un bootloader pour le décompresser
    et l'exécuter.
  \item  \verb+Image+:  \verb+vmlinux+   strippé  et  préfixé  par  un
    mini-bootloader   permettant    de   sauter   sur    la   fonction
    \verb+start_kernel+ de \verb+vmlinux+.
  \item  \verb+bzImage+  et   \verb+zImage+:  \verb+vmlinuz+  avec  le
    bootloader \cmd{bz2} ou \cmd{gz}.
  \item  \verb+xipImage+  :  Idem  \verb+Image+ mais  destiné  à  être
    exécuté  directement  sur un  \emph{eeprom}  sans  être copier  en
    mémoire au préalable.
  \item  \verb+uImage+:  \verb+Image+ avec  une  entête spéciale  pour
    \emph{u-boot}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Le format S3}
  Il est possible  de générer des image au  format SRecord en utilisant
  \cmd{objcopy}
  \begin{lstlisting}
host$ objcopy -O srec vmlinux vmlinux.srec
  \end{lstlisting}
\end{frame}

\subsection{Compiler les modules}

\begin{frame}[fragile=singleslide]{Les modules}
  Une grosse  partie du  noyau peut être  compilé directement  dans le
  noyau ou sous forme de modules.
  \begin{itemize} 
  \item Ils sont marqués par  \c{< >} (non-compilé), \c{<*>} (linké en
    statique) ou \c{<M>} (compilé en module).
  \item  Les modules  peuvent être  apparentés à  des plugins  pour le
    noyau. Il peuvent être chargé et déchargés dynamiquement.
  \item Les modules doivent être présent sur la cible
  \item Les  modules permettent d'alléger la taille  (et améliorer les
    performances) du noyau  et évitent de redémarrer la  cible lors du
    développement
  \item Les  modules ne peuvent  être chargé qu'après le  démarrage du
    noyau.  Par conséquent, certaines  fonctionnalités ne  peuvent pas
    être sous forme de modules
  \item Les  drivers nécessaire au chargements des  modules ne peuvent
    pas être  des modules. Ainsi, si  vos modules sont  sur une flash,
    tous les drivers nécessaires à  l'accès à cette flash doivent être
    statiques 
  \item  Il  est possible  de  développer  des  modules en  dehors  de
    l'arborescence du noyau.
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Les modules et l'installation}
  \begin{itemize} 
  \item \c{make modules} permet de compiler les modules
  \item   \c{make  INSTALL_MOD_PATH=$(pwd)/../target  modules_install}
    copie les modules dans  \c{$INSTALL_MOD_PATH} (= dans le rootfs de
    la cible)
  \item  \c{make modules_prepare}  prepare  les sources  pour que  les
    modules extérieur puissent compiler
  \item   \c{make    INSTALL_PATH=$(pwd)/../target   install}   appelle
    \c{arch/$ARCH/boot/install.sh} qui appelle \c{\~/bin/installkernel}
    ou copie le noyau dans \c{$INSTALL_PATH}
  \item  \c{make  *-pkg}  crée  des  packages  (naïfs)  pour  diverses
    distributions. Ces packages contiennent le noyau et les modules.
  \item
    \c{make   INSTALL_HDR_PATH=$(pwd)/../BSP/include  headers_install}
    copie  les headers dans  \c{$INSTALL_HDR_PATH}.  Ces  headers sont
    suffisants    pour   compiler    les   programmes    de   l'espace
    utilisateur. Si votre toolchain est correctement compilée, vous ne
    devriez pas en avoir besoin.
  \item       Référence:       \file{Documentation/kbuild/kbuild.txt},
    \file{Documentation/make/headers\_install.txt}
  \end{itemize} % $
\end{frame}

\subsection{Faire le ménage}

\begin{frame}[fragile=singleslide]{Clean}
  \begin{itemize}
  \item \c{make clean}  Supprime les fichier objets (qui  ne sont plus
    utiles une fois le noyau compilé)
  \item \c{make mrproper} Supprime tous les résultats de la compilation
    ainsi que les fichiers de configuration
  \item \c{make distclean} Supprime  les résultats de compilation, les
    configurations et fichiers  originaires de l'intégration de patchs
    ou  de  l'édition  de  fichiers  (\c{*~},  \c{*.orig},  \c{*.rej},
    etc...)
  \end{itemize} 
\end{frame} 

\section{Options principales}

\subsection{Configuration globale}

\begin{frame}[fragile=singleslide]{Configuration globale}
  \emph{General setup}:
  \begin{itemize} 
  \item \emph{Prompt for  development and/or incomplete code/drivers}:
    Débloque  les  options  de  compilation  pour  les  drivers/option
    instables (staging, etc...)
  \item  \emph{Cross-compiler  tool  prefix}  :  Affecte  la  variable
    \c{CROSS_COMPILE}
  \item   \emph{Local  version}   :   Ajoute  un   identifiant  à   la
    version. Indispensable  dans les phases  d'intégration. La version
    peut être lue dans  \file{/proc/version}. Il est aussi possible de
    faire \c{make kernelrelease} dans  un répertoire de compilation du
    noyau.
  \item  \emph{Automatically  append  version  information}  :  Ajoute
    l'identifiant git  à la version. Indispensable dans  les phases de
    développement
  \item \emph{Kernel  compression mode}: Permet de choisir  le type de
    compression.   Chaque  algorithme   a  ces  inconvénients  et  ses
    intérêts.
    \note[item]{cf. \url{http://free-electrons.com/blog/lzo-kernel-compression}}
  \item \c{SWAP}: Permet de gérer un espace d'échange dur un disque
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Configuration globale}
  \begin{itemize} 
  \item  \c{SYSVIPC} et  \c{MQUEUE}:  Communication inter-processus
    définis par Posix
  \item \c{IKCONFIG}: Embarque le \file{.config} dans le noyau 
  \item  \c{EXPERT} et  \c{EMBEDDED} Débloque  les  options permettant
    principalement  de réduire la  taille du  noyau en  supprimant des
    modules importants
  \item \c{CC_OPTIMIZE_FOR_SIZE}: Compile avec \c{-Os}
  \item \c{KPROBES},  \c{PERF_EVENTS}, \c{PROFILING}, \c{GCOV_KERNEL}:
    Active les différentes instrumentations du noyau
  \end{itemize} 
\end{frame}

\begin{frame}[fragile=singleslide]{Les périphériques de block}
  \c{MODULES}: Active la gestion des modules
  \\[2ex]
  \c{BLOCK}: Il est possible  de désactiver la gestion des périphérique
  de block si votre système n'utilise que de la mémoire flash.
  \begin{itemize} 
  \item \emph{IO  Schedulers}: Permet de choisir  un ordonnanceur d'E/S
    différent de celui proposé en standard
  \end{itemize} 
  \emph{System type}:
  \begin{itemize} 
  \item Permet de choisir le type d'architecture et de chipset
  \item Il est  possible de désactiver certains cache  lors des phases
    de développement
  \item Vous trouverez aussi dans  ce menu les options relative au jeu
    d'instructions accepté
  \end{itemize}
\end{frame}

\subsection{Fonctionnalités du noyau}

\begin{frame}[fragile=singleslide]{Options de l'horloges}
  \emph{Kernel features}
  \begin{itemize} 
  \item \c{HZ} (pas sur ARM): Définit l'intervalle de réordonnancement
    de l'ordonnanceur.   Plus cette valeur est  forte, plus l'overhead
    introduit par le changement de  contexte est important et plus les
    temps de réponses des tâches sont courts
  \item \c{NO_HZ}: Permet de rendre la période de réordonnancement des
    tâches  dynamique.   Devrait  permettre  un  léger   gain  de  CPU
    (finalement  négligeable avec  l'ordonnanceur  en $o(1)$).  Permet
    surtout de gagner en consommation électrique.
  \item   \c{HIGH_RES_TIMER}:  Gère  les   timers  avec   une  horloge
    différente de  l'ordonnanceur (l'horloge  est alors géré  comme un
    périphérique  à  part).    Permet  d'obtenir  une  bien  meilleure
    précision sur les mesure de  temps, à condition que votre matériel
    possède une horloge \emph{HighRes}.
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{Options de l'ordonnanceur}
  \begin{itemize} 
  \item  \emph{Preemption Model}:  Permet d'activer  la  préemption du
    noyau. Le pire  temps réponse sont améliorés, mais  le temps moyen
    est généralement  moins bon.  Un noyau  préemptif stresse beaucoup
    plus  de  code.  Ne  pas  activer  si  vous utilisez  des  drivers
    extérieur non garanti pour cette option.
  \item \c{RT_PREEMPT} (sur certaines architectures seulement): Permet
    de threader  les IRQ  et ainsi de  remplacer les spinlock  par des
    mutex.  Ajoute un protocole  d'héritage de priorité aux mutex.  Le
    kernel devient alors totalement  préemptif.  A n'utilisez que lors
    d'application  temps   réelle.   Etudiez  des   solutions  à  base
    d'hyperviseurs.
  \item Ne confondez pas la préemption du noyau avec la préemption des
    tâches utilisateur.
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{Option de gestion de la mémoire}
  \begin{itemize} 
  \item \c{EABI},  \c{OABI}, etc...  : Différentes format  d'appel des
    fonctions. Spécifique à ARM (mais très important)
  \item  \emph{Memory Model}: Permet  de gérer  les futurs  systèmes à
    mémoire asymétriques entre les CPU
  \item  \c{COMPACTION}:  Permet de  compresser  les  page de  mémoire
    plutôt  que les mettre  en swap.  Particulièrement utile  dans les
    systèmes sans swap !
  \item  \c{KSM}: Permet  de  fusionner les  page mémoire  identiques.
    Uniquement   utile   avec   des   machines   virtuelles   ou   des
    chroot. Sinon, les  noyau sait que le fichier  est déjà en mémoire
    et ne duplique pas la page
  \end{itemize} 
\end{frame}

\subsection{Les options de boot}

\begin{frame}[fragile=singleslide]{Configuration du boot et du FPE}
  \emph{Boot options}:
  \begin{itemize}
  \item \emph{Flattened Device  Tree} : Utilise \emph{OpenFirmware}, le
    nouveau format de  description matériel appelé aussi \emph{Flatten
      Device Tree}
  \item  \emph{Default kernel  command string}:  Permet de  passer des
    paramètres  par défaut  au noyau  (nous verrons  cela un  peu plus
    loin)
  \item \emph{boot loader address}:  Permettent de démarrer le noyau à
    partir d'une ROM, d'une MMC, etc...
  \item \emph{Kernel Execute-In-Place  from ROM}: Permet d'exécuter un
    noyau non compressé à partir d'une ROM
  \end{itemize}
  \emph{Floating point emulation}: Si  une instruction sur des nombres
  à virgule flottante est rencontrée  et ne peut pas être exécutée, le
  noyau peut alors émuler l'instruction (voir aussi \c{-msoft-float})
\end{frame}

\subsection{Le réseau}

\begin{frame}[fragile=singleslide]{Configuration réseau}
  \emph{Networking}:
  \begin{itemize}
  \item Possibilité  d'activer les innombrables  protocoles réseaux de
    niveaux 1, 2 et 3
  \item  \emph{Network options} : Beaucoup  de fonctionnalité  réseau :
    client dhcp,  bootp, rarp, ipv6, ipsec, les  protocole de routage,
    gestion de QoS, support des VLAN, du multicast,
  \item   \emph{Unix  domain  sockets}   :  Les   sockets  \emph{UNIX}
    (cf. sortie de \c{netstat})
  \item   \emph{TCP/IP   networking}  :   Les   sockets  bien   connue
    \emph{TCP/IP}
  \item  \emph{Netfilter}  :  Le  firewall  de  Linux.   D'innombrable
    options.  Permet l'utilisation d'iptables si l'option \c{IPTABLES}
    est active.
  \end{itemize} 
\end{frame}

\subsection{Les systèmes de fichiers}

\begin{frame}[fragile=singleslide]{Configuration des systèmes de fichiers}
  \emph{File systems}:
  \begin{itemize}
  \item   \emph{Second   extended},   \emph{Ext3  journalling   file},
    \emph{The Extended 4 filesystem}: Le file system standard de Linux
  \item \emph{FUSE}: Permet de  développer des systèmes de fichiers en
    espace utilisateur
  \item \emph{Pseudo  filesystems} Systèmes de  fichiers sans supports
    physiques
    \begin{itemize} 
    \item \c{TMPFS}: File system  volatile en RAM.  Très utilisé avec
      des système en flash vu que  l'accès à la Flash est coûteux en
      temps et destructeur pour la flash
    \item \c{SYSFS} et \c{PROC_FS}:  Permettent au noyau d'exporter un
      certain  nombre de  donnée interne  vers le  userland.  Beaucoup
      d'outils  système tirent  lors informations  de ces  systèmes de
      fichiers.  Ils  doivent être montés dans  \c{/sys} et \c{/proc}.
      \c{/proc} est  plutôt orienté  processus alors que  \c{/sys} est
      orienté modules et paramétrage du noyau.
    \end{itemize} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Configuration des systèmes de fichiers}
  \begin{itemize}
  \item  \emph{Miscellaneous  filesystems}  Contient des  systèmes  de
    fichiers spécifiques
    \begin{itemize} 
    \item  \emph{eCrypt filesystem layer}  : Gestion  transparent d'un
      file system codé
    \item \emph{Journalling  Flash File  System v2} :  Spécialisé pour
      les  Flash avec  gestion de  l'écriture uniforme,  des \emph{bad
        blocks} et des \emph{erase blocks}.
    \item \emph{Compressed ROM file  system}: Spécialisé pour ROM sans
      accès en écriture.
    \item  \emph{Squashed   file  system}:  Idem   \emph{cramfs}  mais
      fortement compressé
    \end{itemize} 
  \item \emph{Network File Systems}
    \begin{itemize}
    \item \emph{NFS client support}  : File system sur ethernet.  Très
      utilisé dans l'embarqué durant les phases de développement
    \item \emph{Root file system on  NFS}: Permet de démarrer le noyau
      sur une partition NFS
    \end{itemize} 
  \end{itemize} 
\end{frame}

\section{Les drivers}

\begin{frame}[fragile=singleslide]{Configuration des Drivers}
  \emph{Device Drivers} Des centaines de drivers. Notons:
  \begin{itemize}
  \item   \emph{path to uevent helper}:  Le  programme   apellé  lorsqu'un
    nouveau            périphérique            est           détecté
    (cf.              \c{/proc/sys/kernel/hotplug}             et
    \c{/sys/kernel/uevent_helper})
  \item  \emph{Maintain a devtmpfs  filesystem to  mount at  /dev}: Un
    tmpfs  spécifique  pour  les  devices  automatiquement  monté  sur
    \file{/dev}.   Les  fichiers  devices sont  alors  automatiquement
    créés sans l'aide d'un programme extérieur.
  \item \emph{Memory Technology Device}: Les flashs
  \item \emph{Staging drivers}: Des drivers en cours de bêta
  \end{itemize} 
\end{frame}

\subsection{Autres options}

\begin{frame}[fragile=singleslide]{Configuration du noyau}
  Mais aussi:
  \begin{itemize} 
  \item \emph{Kernel  Hacking}:  Options  concernant le  débugging  du
    noyau. % Nous y reviendrons dans la section Debug
  \item  \emph{Security  Options}:  Plusieurs framework  permettant  de
    gérer des  droits plus  fin sur les  programmes exécutés  et/ou de
    garantir l'intégrité des donnée à l'aide de TPM.
  \item   \emph{Cryptographic   API}:   Fonctions   de   cryptographies
    sélectionnées     automatiquement     par     d'autres     modules
    (particulièrement les protocoles réseaux)
  \item  \emph{Library routines}: Idem  \emph{Cryptographic API}  mais
    avec principalement des calculs de checksum.
  \end{itemize} 
\end{frame}

\section{Le boot tftp/nfs}

%%% ICI
% Ajouter slide au sujet du boot tftp puis nfs
\begin{frame}[fragile=singleslide]{Boot par tftp/nfs}
  Pour  le  développement  du  noyau,  il est  commun  d'utiliser  les
  technologies :
  \begin{itemize}
  \item \emph{tftp}: Il s'agit  d'un protocole de transfert de fichier
    très simple. Beaucoup de  bootloaders l'implémentent. Il permet un
    démarrage  rapide d'un  nouveau noyau  lors du  développement.  On
    pourra aussi trouver des protocole sur RS232 ou sur USB permettant
    la même fonctionnalité. Comme pour un démarrage normal, on indique
    au bootloader  à quelle  adresse le noyau  doit être chargé  et on
    \emph{jump} à cette adresse
  \item \emph{nfsroot}:  On demande au  noyau de monter  une partition
    réseau. On  dispose ainsi d'un  espace de stockage illimité  et il
    est simple et rapide de mettre à jour le rootfs.
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Notre cas}
  Dans notre cas, nous utilisons U-Boot (standard)
  \begin{itemize}
  \item Compilation
    \begin{lstlisting}
host% apt-get install uboot-mkimage
host$ make O=build ARCH=arm usb-a9260_defconfig
host$ make O=build ARCH=arm CROSS_COMPILE=arm-linux- -j3 uImage
    \end{lstlisting}
  \item Partage de l'image par TFTP
    \begin{lstlisting}
host% cp build/arch/arm/boot/uImage /srv/tftp/uImage-2.6.33.7
host% ln -s uImage-2.6.33.7 /srv/tftp/uImage
    \end{lstlisting} % $ 
  \item  Au   redémarrage,  le   bootloader  passe  par   un  registre
    l'identifiant  de   la  carte.   Cet   identifiant  (spécifique  à
    l'architecture ARM) est erroné. A  ce stade, il est plus facile de
    corriger   ce   problème   dans   le   noyau   dans   le   fichier
    \file{arch/arm/tools/mach-types}.
    \note[item]{C'est mieux de compiler avec -j3}
    \note[item]{Il faut les laisser démarrer en NFS}
    \note[item]{Il faut  commenter la ligne  1108 et changer  la ligne
      1700}
  \end{itemize}
\end{frame}

% Parler de la structure du rootfs

\section{Options de démarrage}
  % La commandline
  % √  init
  % √  root
  % √  ip
  % √  root=/dev/nfs
  % √  console
  %    panic
  %    memarea
  %    mem
  % √  <module>.<option>
\begin{frame}[fragile=singleslide]{Passage d'options au noyau}
  \begin{itemize} 
  \item Il est possible de passer des options au démarrage du noyau
  \item C'est  normalement le bootloader  qui se charge de  passer la
    ligne de commande au noyau
  \item Le bootloader utilise  un protocole prédéfini (lorsqu'il donne
    la  main au noyau,  un des  registre contient  un pointeur  sur la
    ligne de commande)
  \item Il est possible de surcharger  la ligne de commande lors de la
    compilation avec l'option \c{CMDLINE}
  \item   Les   diverses   options   acceptées   sont   décrites   dans
    \file{Documentation/kernel-parameters.txt}
  \item  Il est possible  d'accéder à  la ligne  de commande  après le
    démarrage dans \file{/proc/cmdline}
  \item Il existe  des paramètres globaux au kernel  et des paramètres
    spécifiques à  un module.  Lorsque le module  est compilé  dans en
    statique, il  est possible  de lui passer  des paramètres  avec la
    syntaxe \c{<MODULE_NAME>.<PARAM>=<VALUE>}
  \item Beaucoup d'options sont modifiable à posteriori par \file{/sys}
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Le rootfs}
  \begin{itemize}
  \item \c{root=} indique le disque  à monter sur \file{/}
  \item Sûrement l'option la plus utilisée
  \item  Il est  possible de  spécifier  le nom  d'une partition.  Par
    exemple  \c{root=/dev/sda1} (PC) ou  \c{root=/dev/mtd0} (partition
    flash)
  \item \c{root=/dev/nfs} demande au noyau de démarrer sur NFS
  \item Remarque:  la partition \c{/}  n'étant pas encore  montée, ces
    nom  de partition ne  correspondent pas  à des  fichiers existants
    dans \c{/dev}. Le kernel utilise simplement la même syntaxe.
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{La configuration réseau}
  \begin{itemize}
  \item Il est possible d'initialiser le réseau avant de montage du rootfs
  \item Indispensable pour le démarrage par NFS
  \item Syntaxe: \c{ip=<client-ip>:<server-ip>:<gw-ip>:<netmask>:<hostname>:<device>:<autoconf>} 
  \item Exemple: \c{ip=192.168.1.72:::::eth0:}
  \item  Pour  le  démarrage  par  nfs, il  est  aussi  nécessaire  de
    spécifier    le    répertoire     partagé    par    le    serveur:
    \c{nfsroot=192.168.1.10:/srv/nfs}
  \item  Il aussi possible  de démarrer  en utilisant  un DHCP  (ou un
    autre protocole d'auto-négociation): \c{ip=on}
  \end{itemize}
\end{frame} 

\begin{frame}[fragile=singleslide]{La configuration réseau}
  \begin{itemize} 
  \item  Il est  alors possible  de spécifier  le \c{nfsroot}  dans la
    configuration du serveur DHCP:
     \begin{lstlisting} 
host target {
    option root-path "192.168.1.10:/srv/nfs";
    next-server 192.168.1.10;
    hardware ethernet 00:26:24:3a:14:5c;
    fixed-address 192.168.1.72;
}
     \end{lstlisting} 
   \item  Lors du  démarrage NFS,  attention aux  modifications  de la
     configuration réseau postérieure au montage du rootfs
    \item Référence: \file{Documentation/filesystems/nfs/nfsroot.txt}
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Démarrage du noyau}
  \begin{itemize}
  \item  A  la fin  du  démarrage  du noyau,  celui  donne  la main  à
    l'exécutable déclaré  avec \verb+init=+. Par défaut,  il s'agit de
    \file{/sbin/init}
  \item \cmd{init} ne se termine jamais
  \item  Les  arguments  non-utilisés   par  le  noyau  sont  passé  à
    \cmd{init}
  \item On peut  estimer que notre système démarre  à partir du moment
    ou nous obtenons un shell (c'est en tous cas la que la plupart des
    intégrateur Linux embarqué s'arrêteront)
  \item Du moins complexe au plus complexe à démarrer:
  \begin{itemize}
    \item \verb+init=/hello-arm-static+
    \item \verb+init=/hello-arm+
    \item \verb+init=/bin/sh+
    \item \verb+init=/sbin/init+
    \end{itemize}
  \end{itemize}
  Effectuons ces tests avec le Rootfs original et un Rootfs vierge.
\end{frame}

\begin{frame}[fragile=singleslide]{La console}
  \begin{itemize} 
    \item Sûrement la deuxième option la plus utilisée
    \item  \c{console=}  permet de  demander  au  noyau d'afficher  la
      sortie de \c{printk} sur un périphérique spécifique.
    \item Sur PC, souvent limité à \c{console=ttyS0,115200n8}.
    \item Sur  un système  embarqué, il existe  beaucoup de  driver de
      ports  séries différents.   \c{console} peut  alors  prendre des
      valeurs exotiques. A voir au cas par cas pour chaque driver.
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Panic}
  \begin{itemize} 
  \item  Un   \emph{kernel  panic}   est  une  erreur   détectée  mais
    irrécupérable
  \item \c{panic=X}  permet demande au  noyau de redémarrer  après $X$
    secondes en cas de \emph{kernel panic}
  \item Par défaut,  le noyau ne redémarre pas  en cas de \emph{kernel
      panic}
  \end{itemize} 
\end{frame} 

  %   mem
  %   memmap
\begin{frame}[fragile=singleslide]{La mémoire}
  \begin{itemize} 
  \item Il est parfois nécessaire de donner des instructions au kernel
    sur l'utilisation qu'il peut faire des espaces mémoires
  \item \c{mem=nn}  Force la  taille de la  mémoire que le  noyau peut
    utiliser. Sur beaucoup de  plateformes, le noyau n'est pas capable
    de détecter la capacité de la mémoire.
  \item  \c{memmap=nn@ss}   et  \c{memmap=nn$ss}  Force   le  noyau  à
    n'utiliser que la mémoire entre \c{ss} et \c{ss+nn}
  \item \c{memmap=nn@ss}  et \c{memmap=nn$ss} Force le noyau  à ne pas
    utiliser la mémoire entre \c{ss} et \c{ss+nn}
  \item Il est possible d'utiliser plusieurs fois ces options
  \item Utiles pour rapidement réservés des espace d'adresse d'E/S pas
    encore défini  dans la configuration  ou se réserver des  blocs de
    mémoire   particuliers  pour   la   communication  avec   d'autres
    périphériques
  \end{itemize}
\end{frame}

% \section{Initramfs}

% \begin{frame}[fragile=singleslide]{Initramfs}
%   Qu'est-ce qu'un initramfs?
%   \begin{itemize}
%   \item  Un  petit  système  de  fichiers chargé  en  mémoire  par  le
%     bootloader
%   \item Successeur de initrd (plus complexe d'utilisation)
%   \item Permet d'éffectuer des actions avant le lancement d'init
%   \item Il devrait rester petit et ne s'utiliser que pour continuer le
%     boot
%   \item  Si  vous  intégrez  busybox  dans  votre  initramfs,  il  est
%     préconisé  de  le compiler  en  statique  en  ne gardant  que  les
%     composant utiles
%   \item  Cas classique:  charger les  modules permettent  d'accéder au
%     système de fichier:
%     \begin{itemize}
%     \item M-Sys Disc-On-Chip
%     \item Configuration RAID
%     \item Configuration réseau pour booter en NFS
%     \end{itemize}
%   \item Dans notre cas, il n'est pas utile car nous n'avons pas besoin
%     de charger de driver particuliers avant le démarrage
%   \end{itemize}
% \end{frame}  

% \begin{frame}[fragile=singleslide]{Initramfs}
%   \begin{itemize} 
%   \item Création d'un rootfs vraiment minimal:
%     \begin{lstlisting}[language=sh]
% host$ mkdir initramfs
% host$ cd initramfs
% host$ mkdir dev
% host$ mknod dev/console c 5 1
% host% cp .../hello-arm-static init
% host$ find . |  cpio -o | gzip > initramfs.gz
%     \end{lstlisting} %$
%   \item Comme l'image noyau, l'image initramfs doit être au format u-boot.
%     \begin{lstlisting} 
% host$ mkimage -A arm -T ramdisk -d initramfs.gz initramfs.gz.img
% host$ cp initramfs.gz.img /srv/tftp
% uboot> tftp 22000000 initramfs.gz.img
%     \end{lstlisting}
%   \end{itemize}
% \end{frame}

% \begin{frame}[fragile=singleslide]{Initramfs}
%   \begin{itemize} 
%   \item  On  indique  l'adresse   du  ramfs  en  second  paramètre  de
%     \cmd{bootm}. Evidement, le noyau doit être configuré pour utiliser
%     le ramfs.
%     \begin{lstlisting} 
% uboot> setenv autostart no
% uboot> tftp 22000000 initramfs.gz.img 
% uboot> tftp 21000000 uImage 
% uboot> bootm 21000000 22000000 
%     \end{lstlisting}
%   \item  Il est aussi  possible de  compilerle noyau  directement avec
%     l'initramfs
%   \item Référence \file{Documentation/early-userspace/README}
%   \end{itemize}
%   \note[item]{TODO P1 A verifier, tester, completer}
% \end{frame}

\section{Fabrication d'un BSP}

\begin{frame}[fragile=singleslide]{Etape de fabriquation d'un BSP}
  \begin{itemize}
  \item  Commencez par compiler  une toolchain  si celle-ci  n'est pas
    fournie.
  \item  Si le  bootloader est  fourni, travaillez  avec  celui-ci. Il
    arrive souvent que les bootloader initialisent certains paramètres
    du CPU sans lesquels le noyau ne peut démarrer
  \item Si  vous n'avez pas  de bootloader, vous devrez  commencez par
    paramétrer une sonde JTAG
  \item  Sinon, vous  pouvez développer  le  noyau et  le bootloader  en
    parallèle. Sans  bootloader, vous  devrez utiliser une  sonde JTAG
    pour démarrer votre cible
  \item  Configurer   le  noyau  jusqu'à   pouvoir  démarrer  l'espace
    utilisateur
  \item Compiler un busybox pour l'espace utilisateur
  \item Faites fonctionner les différents périphériques
  \item Intégrer  votre toolchain,  votre bootloader, les  fichiers de
    configuration de  votre noyau et  de votre busybox, vos  outils et
    drivers spécifique dans un outil tel que BuildRoot
  \item Zipper l'ensemble
  \item Compilez l'ensemble et zipper le résultat
  \item Intégrez vos modification dans l'upstream
  \end{itemize}
\end{frame} 




