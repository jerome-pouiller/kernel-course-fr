%
% This document is available under the Creative Commons Attribution-ShareAlike
% License; additional terms may apply. See
%   * http://creativecommons.org/licenses/by-sa/3.0/
%   * http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
% Created: 2012-03-13 00:08:25+01:00
% Main authors:
%     - Jérôme Pouiller <jezz@sysmic.org>
%

\part{Compiler}

\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \tableofcontents[currentpart]
\end{frame}

\section{Obtenir le noyau}

\begin{frame}[fragile=singleslide]{Qu'est-ce qu'un BSP?}
  \begin{itemize} 
  \item \emph{Board Support Package (BSP)}
  \item Normalement fourni par l'intégrateur.
  \item  Contient  au   minimum  la  toolchain  (compilateur,  linker,
    debuggueur) pour la cible, au  minimum les sources, et souvent des
    versions pré-compilées
  \item  Cette toolchain est  souvent compilée  avec une  libc (glibc,
    µclibc, newlib,  bionic, eglibc,  dietlibc, kilbc, etc...)  et une
    version des binutils. Si ça n'est pas le cas, elle pourra compiler
    le noyau Linux, mais aucune binaire utilisateur.
  \item  Contient souvent  le  bootloader (sources  et/ou binaire)  le
    noyau  Linux  (au minimum  les  sources,  et  parfois une  version
    pré-compilée).
  \item Si la  cible possède des drivers spécifique  externes à Linux,
    ils doivent (devraient) être fournis avec la toolchain.
  \item  De même,  si la  cible doit  utiliser  certaine bibliothèques
    spécifiques, elle sont normalement fournies
  \item Contient la documentation (parfois incomplète...)
  \item Assez souvent, une arborescence de fichier est fournie
\end{itemize} 
\note{A intégrer dans embede_linux}
\end{frame} 


  % git
  %   tag: Une version particuliere avec "git co"
  %   Les differents depots
  % http
\begin{frame}[fragile=singleslide]{Récupération des sources}
  Ou récupérer les sources du noyau?
  \begin{itemize} 
  \item Utiliser les sources souvent  fournies avec le BSP.  Il arrive
    souvent qu'elles contiennent  des drivers particuliers et qu'elles
    soient déjà configurées
  \item Télecharger sur \file{kernel.org}
    \note[item]{Fonctionne aussi avec 2.6.37}
    \begin{lstlisting}[language=sh]
host$ wget http://www.kernel.org/pub/linux/kernel/v3.x/linux-3.3.tar.bz2
host$ tar xvjf linux-3.3.tar.bz2
    \end{lstlisting}
  \item Utiliser \cmd{git clone}
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Versionning}
  \begin{itemize}
  \item Au début, le noyau s'incrémentait de 2 en deux: 2.0, 2.2, 2.4,
    etc... Les version impaires indiquait les noyau en développement.
  \item Chaque version du noyau apportait des ruptures importante avec
    la version précédente
  \item Avec le noyau 2.5 puis 2.6, le noyau est arrivé à une certaine
    maturité.   Les  gros   changements  sont   devenu  rare   et  les
    développement sont devenu de plus en plus itératifs
  \item Finalement  dans la version 2.6, toutes  les versions mineures
    sont stables
  \item Les version  stable de la 2.6 peuvent  recevoir des correctifs
    et sont alors numérotés sur 4 chiffres
  \item Le  noyau 2.6 fonctionne  par intégration de  patchs provenant
    des sous-système  les noyau produit  lors de l'intégration  de ses
    patchs est suffixé par \texttt{rcX} (release candidate).
  \item Le noyau  alterne les fenêtres de merge  pendant lesquels, les
    mainteneurs des sous-système  envoient leur développements à Linus
    Tovalds et fenêtre de stabilisation.
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Versionning}
  \begin{itemize}
  \item La version 3.0 est fait la version 2.6.40 renommé:
    \begin{itemize}
    \item Pour fêter les 20ans du kernel
    \item Il n'y a eu aucune refonte entre les version 2.6 et 3
    \item Pour marquer l'intégration  de la branche RT-Preempt dans le
      mainstream
    \item  Parce  qu'avec  le  cycle de  développement  itératif,  la
      version 2.6 ne s'incrémentera jamais. Les version stable quant à
      elles  peuvent recevoir  des  correctif et  se  retrouver sur  4
      chiffres.  Il y  avait par  conséquent un  chiffres en  trop. Le
      passage en 3.Y.Z permettait de revenir sur un modèle classique à
      3 chiffres.
    \item Le passage en 3.X  marque aussi la stabilisation du cycle de
      développement du noyau
    \end{itemize} 
  \item Référence : \file{Documentation/development-process}
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Git}
  \begin{itemize} 
  \item \cmd{git} est l'outil de gestion de source du noyau
  \item  Il est fortement  recommander de  l'utiliser dans  le cadre
    d'un développement du noyau
  \item Il s'agit d'un système de gestion décentralisé. 
  \item Pour expliquer la décentralisation, imaginez que
    \begin{itemize} 
    \item vous dupliquez un dépôt svn
    \item vous faites des modifications sur les deux dépôts
    \item vous essayez de resynchronisez les deux...
    \item  Considérez  git  comme  un svn  capable  d'effectuer  cette
      opération très simplement.
    \item Lorsque vous récupérez le code d'un dépôt, vous devenez vous
      même dépôt
    \item Si  vous laissez  un moyen quelconque  d'accès en  lecture à
      votre dépôt, d'autres personne pourrons à leur tour le cloner ou
      tirer les modification que vous avez effectuez
    \end{itemize} 
  \item  \url{http://git.kernel.org} liste  les  dépôts publiques  des
    principaux développeurs du noyau
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Git}
  \begin{itemize} 
  \item Pour récupérer un dépôt:
    \begin{lstlisting} 
git clone <depôt>
    \end{lstlisting} 
  \item Remarquons en particulier:
    \begin{itemize} 
    \item
      \url{git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git}
      Le dépôt de  Linus Torvalds. Il contient les  derniers patchs du
      noyau en développement
    \item
      \url{git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git}
      Le depôt  stable. Contient la dernière version  stable du noyau,
      ainsi les patchs des version stables.
    \item
      \url{git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git}
      Les  dépôt une  dizaine  de sous-projets  importants sont  mergés
      automatiquement dans  ce dépôt.  Utilisé  principalement par des
      robots afin  d'identifier les problème  de merge en  amont des
      phases d'intégrations
    \item
      \url{git://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git}
      L'historique des versions entre 2.5.0 et 2.6.12.
    \end{itemize} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Git}
  \begin{lstlisting}[language=sh]
host$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
  \end{lstlisting} 
  Chaque version du noyau est marquée avec un tag
  \begin{lstlisting} 
host$ git tag
  \end{lstlisting} 
  Puis il est possible de récupérer une version avec
  \begin{lstlisting}
host$ git checkout v3.3
  \end{lstlisting}
  Votre dépôt est alors  non-modifiable.  Vous devez créer une branche
  de travail:
  \begin{lstlisting}
host$ git checkout -b mybranch v3.3
  \end{lstlisting}
\end{frame}

\section{Organisation des sources}

\begin{frame}[fragile=singleslide]{Organisation des sources}
  On remarque qu'il existent d'énorme différences de tailles entre les
  répertoires:
  \begin{lstlisting}
$ du -s */ | sort -n | column
40      usr              4092    scripts
156     samples          5248    kernel
160     init             6436    firmware
180     virt             19524   Documentation
232     ipc              21332   net
884     block            22728   include
1904    crypto           24016   sound
1932    lib              32436   fs
2076    security         121584  arch
2400    mm               252688  drivers
3536    tools
  \end{lstlisting} 
\end{frame}

\begin{frame}[fragile=singleslide]{Organisation des sources}
  \begin{itemize} 
  \item Les services indispensable à un OS:
    \begin{itemize} 
    \item  \file{kernel}  Le scheduler  de  tâches,  les framework  de
      gestion  des   IRQ,  le  loader  de   binaires,  diverses  autre
      fonctionnalités ne rentrant dans aucune autre catégories.
    \item  \file{mm} Le  gestionnaire de  mémoire. Considéré  comme la
      partie la plus complexe du noyau
    \item   \file{init}   La    fonction   de   démarrage   du   noyau
      (\c{start_kernel}).
    \item  \file{arch} Le  code spécifique  à chaque  architecture. En
      particulier,  le code nécessaire  au boot,  à la  génération des
      images,   les   routine   assembleur   pour   la   gestion   des
      interruptions, etc...
      % \item \file{init} Le \emph{bootloader} du noyau. Petit morceau
      %   de  code  capable  de  décompresser  le noyau  avant  de  le
      %   démarrer (\c{start_kernel}).
    \item  On peut  estimer que  l'intelligence  réside principalement
      dans \file{kernel}  et \file{mm}.  On remarque cette  partie est
      finalement relativement petite dans le noyau.
    \end{itemize} 
  \item Les services supplémentaire du noyau:
    \begin{itemize}
    \item \file{fs} Les filesystems: ext3, NTFS, NFS, etc...
    \item \file{net} La gestion  du réseau et plus particulièrement la
      stack IP
    \item  \file{ipc}  La  gestion  des  communication  interprocessus
      (shmem, mq, etc..)
    \item  \file{security} Les  framework  de gestion  de la  sécurité
      (selinux, apparmor,  etc..)  
    \end{itemize} 
  \end{itemize}  
\end{frame}

\begin{frame}[fragile=singleslide]{Organisation des sources}
  \begin{itemize} 
  \item Les drivers
    \begin{itemize} 
    \item \file{block} Le framework des périphériques block.
    \item \file{sound} Les drivers de cartes son.
    \item \file{virt/kvm} Le framework de virtualisation kvm.
    \item  \file{drivers/*} Tous  les autres  drivers et  framework de
      développements. De loin la plus grosse partie du code du noyau.
    \item \file{firmware}  Certains périphériques nécessitent l'upload
      d'un firmware  pour s'initialiser. \file{firmware}  contient les
      binaires de  ces firmware (sans  les sources!). La  politique de
      Linux  au sujet du  code de  ces firmwares  est qu'il  s'agit de
      données  d'initialisation  de   ces  périphériques  et  que  par
      conséquent, ils ont leurs place dans l'arborescence du noyau.
    \end{itemize} 
  \item Des bibliothèques utilitaires:
    \begin{itemize} 
    \item \file{lib} Divers utilitaires
    \item   \file{crypto}  Fonctions   utilitaires   relatives  à   la
      cryptographie
    \end{itemize} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Organisation des sources}
  \begin{itemize} 
  \item Le code annexe:
    \begin{itemize} 
    \item \file{include} Les headers exposés du noyau.
    \item  \file{scripts} Les  scripts ou  les  programmes utilitaires
      nécessaires à la compilation ou à l'exploitation du noyau
    \item \file{usr} Script nécessaire à la génération des initramfs
    \item  \file{tools}  Les  outils  permettant la  communication  de
      certains frameworks avec le noyau (particulièrement \c{perf})
    \end{itemize} 
  \item La documentation
    \begin{itemize} 
    \item \file{Documentation} La documentation
    \item \file{sample} Des exemples de code pour certains framework
    \end{itemize} 
  \end{itemize} 
\end{frame} 
% Cohérence: 
%   sound -> drivers/sound
%   block -> drivers
%   virt alors que xen se trouver dans drivers
%   usr, tools et scripts redondant
%   Pourquoi Documentation prend un D majuscule?

\begin{frame}[fragile=singleslide]{Les architectures}
  Regardons \file{arch/} de plus près:
  \begin{itemize} 
  \item Les PC: \file{x86}
  \item Les  workstations et les  serveurs: \file{alpha}, \file{sparc}
    (Sun),    \file{ia64}    (Intel),   \file{powerpc},    \file{s390}
    (Mainframes d'IBM) \file{parisc} (Workstation HP)
  \item     L'embarqué:     \file{arm},     \file{mips},     \file{sh}
    (STMicroelectronics),   \file{avr32},  \file{m68k},  \file{score},
    \file{mn10300}, \file{m32r} \file{h8300}
  \item  Les architectures  dédiées:  \file{cris} (Embedded  Network),
    \file{frv} (Futjisu, Traitement d'image)
  \item  Les   DSP:  \file{c6x}  (Texas   Instrument),  \file{heaxgon}
    (Qualcomm), \file{blackfin}
  \item Les softcores: \file{microbaze}, \file{xtensa}
  \item  Les   expérimentaux  \file{tile}  (Architecture  distribuée),
    \file{unicore32} (Université de Pekin), \file{openrisc}
  \item User Mode Linux: \file{um}
  \end{itemize} 
  On retrouve nos 26 (+1) architectures supportées
\end{frame}    

\begin{frame}[fragile=singleslide]{Le code spécifiques aux architectures}
  \begin{itemize} 
  \item On retrouve dans  les sous-répertoire de \file{arch/} certains
    répertoires de la racine.
  \item  \file{mach-}, \file{plat-}, \file{plateforms}  contiennent du
    code spécifique  à un  type de plateformes:  Ti Omap,  Atmel AT91,
    PowerPC 85xx
  \item    On   pourra   trouver    des   fichiers    spécifique   aux
    \emph{board}.  Particulièrement vrai  pour  les architectures  non
    plug-and-play qui nécessite  que les périphériques soient déclarés
    manuellement
  \item   \file{include/}   contient   des   headers   spécifiques   à
    l'architecture. Lors  de la  compilation, un lien  symbolique sera
    créé         entre        \file{arch/<ARCH>/include/asm}        et
    \file{include/asm}. Ce  lien permet au noyau de  s'abstraire de la
    plateforme
  \item \file{boot/}  contient le code  nécessaire au démarrage  de la
    cible:
    \begin{itemize}
    \item  Le  code  du  \emph{bootloader}  et  les  scripts  associés
      permettant la décompression du noyau en mémoire
    \item Les scripts nécessaire à la génération d'une image au format
      du bootloader, du flasher ou de la sonde JTAG
    \end{itemize} 
  \end{itemize} 
\end{frame} 

\section{Compiler le noyau}

  % Les cibles principales
  %   O=
  %   V=
  %   C=
  %   -j X
  %   defconfig
  %   menuconfig/nconfig
  %   oldconfig
  %   modules
  %   modules_install
  %   *Image
  %   clean/distclean/mrproper
% host$ make ARCH=arm CROSS_COMPILE=arm-linux- menuconfig

\subsection{Gérer les configurations}
\begin{frame}[fragile=singleslide]{Fonctionnement de Kconfig}
  \begin{itemize}
  \item Système de compilation du noyau
  \item Application de la règle: "Pas générique mais simple à hacker"
  \item Dépend principalement de \cmd{gmake}
  \item  Pas un  système de  compilation réel. Composé de :
    \begin{itemize}
    \item Kconfig, Système de gestion de configuration
    \item Kmake, règles Makefile bien étudiées
    \end{itemize}
  \item   Adapté  aux  environnements   avec  beaucoup   d'options  de
    configuration
  \item Très bien adapté à la cross-compilation
  \item Utilisé dans d'autre projets: µclibc, busybox, buildroot (tous
    dans le milieu de l'embarqué)
\end{itemize}
\end{frame} 

\begin{frame}[fragile=singleslide]{Le système de compilation}
\begin{itemize} 
  \item Pour obtenir de l'aide sur les différentes cibles:
    \begin{lstlisting}
host$ make help
    \end{lstlisting} 
  \item  La variable  \c{ARCH=}  impacte les  options  du noyau.  Elle
    spécifie l'architecture à utiliser.  comparez \cmd{make help} avec
    \cmd{make ARCH=arm help}. 
  \item   Si   \c{ARCH}   n'est   pas   spécifiée,   Kconfig   utilise
    l'architecture \emph{host}.
  \item Lorsque  vous avez commencé  à spécifier \c{ARCH},  vous devez
    toujours la  spécifier. 
  \item Il  est toutefois  possible de placer  cette variable  dans le
    Makefile racine ou dans l'environnement pour éviter de l'oublier.
    \begin{lstlisting}
host$ export ARCH=arm 
    \end{lstlisting} 
  \end{itemize} 
\end{frame} 

  %   defconfig
  %   oldconfig
\begin{frame}[fragile=singleslide]{Travailler avec les configurations}
  \begin{itemize} 
  \item \c{make  help} propose des configurations  préétablie. Il est
    possible d'importer une de ces configuration:
    \begin{lstlisting} 
host$ make ARCH=arm usb-a9260_defconfig
    \end{lstlisting} 
  \item Kconfig sauvegarde la configuration dans \file{.config}. 
  \item Le fichier \file{.config} sera ensuite:
    \begin{itemize} 
    \item Sourcé dans les système de Makefile
    \item Transformé  en \file{include/generated/autoconf.h} et inclut
      dans les headers de compilations
    \end{itemize} 
  \item Certains  constructeur vous  fournirons un patch  ajoutant une
    cible \c{_defconfig}
  \item D'autre vous fournirons un \file{.config}
\end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Travailler avec les configurations}
  \begin{itemize} 
  \item  Lorsque  votre   fichier  \file{.config}  n'est  parfaitement
    compatible  avec vos sources  (import, mise  à jours  des sources,
    édition manuellle, ...), il recommandé (nécessaire?) de lancer
    \begin{lstlisting} 
host$ make oldconfig
    \end{lstlisting} 
    \c{oldconfig}  vous  indique  d'éventuelles incompatibilité  entre
    votre configuration et vos sources  et vous demande votre avis sur
    les nouvelles options
  \item Pour répondre systématiquement avec la réponse par défaut:
    \begin{lstlisting} 
host$ yes "" | make oldconfig
    \end{lstlisting} 
  \item Obtenir  la liste  des nouvelles options  par rapport  à votre
    configuration:
   \begin{lstlisting} 
host$ make listnewconfig
   \end{lstlisting} 
 \item Vous  pouvez normalement trouver  la configuration du  noyau de
   votre \emph{host} dans \c{/boot/config-`uname -r`}
 \item Sauver votre configuration en effectuant un \emph{sanity check}
   \begin{lstlisting}  
host$ make savedefconfig
   \end{lstlisting} 
  \item Référence: \file{Documentation/kbuild/kconfig.txt}
 \end{itemize}
\end{frame} 

\subsection{Modifier les configurations}
  %   menuconfig/nconfig
\begin{frame}[fragile=singleslide]{Configurer le noyau}
 Pour configurer les options:
 \begin{itemize}    
 \item En ligne de commande (inutilisable pour un humain)
   \begin{lstlisting}
host$ make config
   \end{lstlisting} %$
 \item En ncurses
   \begin{lstlisting}
host% apt-get install libncurses5-dev
host$ make menuconfig
   \end{lstlisting} %$
 \item Avec la nouvelle version de ncurses 
   \begin{lstlisting}
host% apt-get install libncurses5-dev
host$ make nconfig
   \end{lstlisting} %$
\end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Configurer le noyau}
\begin{itemize} 
 \item En Qt4
   \begin{lstlisting}
host% apt-get install libqt4-dev
host$ make xconfig
   \end{lstlisting} %$
 \item En Gtk
   \begin{lstlisting}
host% apt-get install libglade2-dev
host$ make gconfig
   \end{lstlisting} %$
 \item Dans  toutes les  interfaces, il est  possible d'obtenir  de la
   description sur l'élément sélectionné (\c{<h>} ou \c{<?>})
 \item  Il  est  possible  de  rechercher dans  les  descriptions  des
   éléments (\c{</>})
 \item  Dans   la  recherche  et  dans  l'aide,   vous  trouverez  des
   informations sur les dépendances entre les options
 \item   Les  script  \cmd{scripts/config}   permet  de   changer  les
   configuration à la main
 \end{itemize}
\end{frame}

\subsection{Compiler}
\begin{frame}[fragile=singleslide]{Les cibles de compilation}
  \begin{itemize} 
  \item  La compilation  du noyau  se lance  juste avec 
    \begin{lstlisting} 
host$ make
    \end{lstlisting} 
  \item Le  système choisi les  cible appropriée en fonction  de votre
    architecture (principalement, une image et les modules)
   \item Il est souvent  préférable (nécessaire?) de spécifier le type
     d'image voulue avec
    \begin{lstlisting}
host$ make XXImage
    \end{lstlisting}
  \item \verb+XX+ fait référence au format de la binaire produite:
    \begin{itemize}
    \item Le premier octet est-il du code?
    \item Respecte-t-il le format ELF?
    \item Y a-t-il un format particulier d'entête à respecter ?
    \end{itemize}
  \item Dans  le doute,  il faut consulter  la documentation  de votre
    bootloader
  \end{itemize}
\end{frame} 

\begin{frame}[fragile=singleslide]{Options de Kmake}
  Certaines options peuvent être passées sur la ligne de commande afin
  de modifier le comportement général du système.
  \begin{itemize}
  \item  \c{ARCH=} spécifie l'architecture  à utiliser.  (Nous l'avons
    déjà vu)
  \item \c{CROSS_COMPILE=} spécifie le préfixe de la toolchain. Ainsi,
    si vous  compilez avec \cmd{/opt/arm/usr/bin/arm-linux-ulibc-gcc},
    vous                        devez                       spécifier:
    \c{CROSS_COMPILE=/opt/arm/usr/bin/arm-linux-ulibc-}.            Par
    commodité,  on  préférera   ajouter  \cmd{/opt/arm/usr/bin}  à  la
    variable  d'environnement  \cmd{PATH}.  Il  est aussi  possible  de
    configurer \c{CROSS_COMPILE} par Kconfig
  \item \c{V=1} permet d'afficher les commandes lancées par le système
    de build plutôt que la  version abrégée. Pas très lisible lors des
    compilation parallèle mais indispensable pour comprendre certaines
    erreur de compilation
  \item De base, le noyau n'active que les warnings utiles (ainsi, les
    warnings  produits sont rarement  à ignorer).   \c{W=[123]} permet
    d'activer des warnings supplémentaires
\end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Options de Kmake}
\begin{itemize} 
  \item  \c{C=\{1,2\}} lance  l'outil  sparse sur  les  sources. Nous  y
    reviendrons.
  \item  \c{-jX} est  une option  de \cmd{make}  qui permet  de lancer
    \c{X}  compilation simultanées.  Grosso modo,  \c{X}  devrait être
    plus ou moins votre nombre de coeurs CPU.
  \item \c{O=} permet de compiler \emph{out-of-source}:
    \begin{lstlisting}
host$ mkdir build
host$ make ARCH=arm CROSS_COMPILE=arm-linux- O=build menuconfig
    \end{lstlisting} %$
    Tous  les  fichier  issus  de  la génération  seront  placés  dans
    \file{build}.  Une fois  que  votre configuration  est crée,  vous
    pouvez lancer \cmd{make} directement  à partir de \file{build}. La
    compilation  \emph{out-of-source} permet  une grande  souplesse de
    développement et est fortement recommandée.
  \item Référence: \file{Documentation/kbuild/kbuild.txt}
  \end{itemize} 
\end{frame}

\begin{frame}[fragile=singleslide]{Compilation du noyau}
  Fichiers produits (ou productibles) par la compilation:
  \begin{itemize}
  \item  \verb+vmlinux+:  L'image  ELF  du  noyau.   Lisible  par  les
    debugueurs, certains flasheurs, certain bootloaders
  \item  \verb+vmlinuz+: parfois  équivalent  du \verb+bzImage+,  mais
    normalement, il  s'agit de\verb+vmlinux+ compressé  et strippé des
    informations inutiles  au démarrage. Inutilisable  dans l'état, il
    est nécessaire de lui adjoindre un bootloader pour le décompresser
    et l'éxecuter.
  \item  \verb+Image+:  \verb+vmlinux+   strippé  et  préfixé  par  un
    mini-bootloader   permettant    de   sauter   sur    la   fonction
    \verb+start_kernel+ de \verb+vmlinux+.
  \item  \verb+bzImage+  et   \verb+zImage+:  \verb+vmlinuz+  avec  le
    bootloader \cmd{bz2} ou \cmd{gz}.
  \item  \verb+xipImage+  :  Idem  \verb+Image+ mais  destiné  à  être
    exécuté  directement  sur un  \emph{eeprom}  sans  être copier  en
    mémoire au préalable.
  \item  \verb+uImage+:  \verb+Image+ avec  une  entête spéciale  pour
    \emph{u-boot}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Le format S3}
  Il est possible  de générer des image au  format SRecord en utilisant
  \cmd{objcopy}
  \begin{lstlisting}
host$ objcopy -O srec vmlinux vmlinux.srec
  \end{lstlisting}
\end{frame}

\subsection{Compiler les modules}
  %   modules
  %   modules_install
\begin{frame}[fragile=singleslide]{Les modules}
  Une grosse  partie du  noyau peut être  compilé directement  dans le
  noyau ou sous forme de modules.
  \begin{itemize} 
  \item Ils sont marqués par  \c{< >} (non-compilé), \c{<*>} (linké en
    statique) ou \c{<M>} (compilé en module).
  \item  Les modules  peuvent être  apparentés à  des plugins  pour le
    noyau. Il peuvent être chargé et déchargés dynamiquement.
  \item Les modules doivent être présent sur la cible
  \item Les  modules permettent d'alléger la taille  (et améliorer les
    performances) du noyau  et évitent de redémarrer la  cible lors du
    développement.
  \item Les  modules ne peuvent  être chargé qu'après le  démarrage du
    noyau.  Par conséquent, certaines  fonctionnalités ne  peuvent pas
    être sous forme de modules
  \item Les  drivers nécessaire au chargements des  modules ne peuvent
    pas être  des modules. Ainsi, si  vos modules sont  sur une flash,
    tous les drivers nécessaires à  l'accès à cette flash doivent être
    statiques.
  \item  Il  est possible  de  développer  des  modules en  dehors  de
    l'arborescence du noyau.
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Les modules}
  \begin{itemize} 
  \item \c{make modules} permet de compiler les modules
  \item   \c{make  INSTALL_MOD_PATH=$(pwd)/../target  modules_install}
    copie les modules dans  \c{$INSTALL_MOD_PATH} (= dans le rootfs de
    la cible)
  \item  \c{make modules_prepare}  prepare  les sources  pour que  les
    modules extérieur puissent compiler
  \item   \c{make    INSTALL_PATH=$(pwd)/../target   install}   appelle
    \c{arch/$ARCH/boot/install.sh} qui appelle \c{\~/bin/installkernel}
    ou copie le noyau dans \c{$INSTALL_PATH}
  \item  \c{make  *-pkg}  crée  des  packages  (naifs)  pour  diverses
    distributions. Ces packages contiennent le noyau et les modules.
  \item
    \c{make   INSTALL_HDR_PATH=$(pwd)/../BSP/include  headers_install}
    copie  les headers dans  \c{$INSTALL_HDR_PATH}.  Ces  headers sont
    suffisants    pour   compiler    les   programmes    de   l'espace
    utilisateur. Si votre toolchain  est correctement compilée, vous ne
    devriez pas en avoir besoin.
    \item Référence: \file{Documentation/kbuild/kbuild.txt}
  \end{itemize}
\end{frame} 

  %   clean/distclean/mrproper
\begin{frame}[fragile=singleslide]{Clean}
  \begin{itemize}
  \item \c{make clean}  Supprime les fichier objets (qui  ne sont plus
    utiles une fois le noyau compilé)
  \item \c{make mrproper} Supprime tous les résultats de la compilation
    ainsi que les fichier de configuration
  \item \c{make distclean} Supprime  les résultats de compilation, les
    configuration et fichier originaires de l'intégration de patchs ou
    de l'édition de fichiers (\c{*~}, \c{*.orig}, \c{*.rej}, etc...)
  \end{itemize} 
\end{frame} 

\section{Options principales}

\begin{frame}[fragile=singleslide]{Configuration globale}
  \emph{General setup}:
  \begin{itemize} 
  \item  \c{EXPERIMENTAL}: Débloque les  options de  compilation pour
    les drivers/option instables (staging, etc...)
  \item \c{CROSS_COMPILE}: Affecte la variable \c{CROSS_COMPILE}
  \item    \c{LOCALVERSION}:    Ajoute    un   identifiant    à    la
    version. Indispensable dans les phases d'intégration. La version
    peut  être lue  avec \c{uname  -r}. ITEM  est aussi  possible de
    faire \c{make  kernelrelease} dans un  répertoire de compilation
    du noyau.
  \item  \c{LOCALVERSION_AUTO}:   Ajoute  l'identifiant  git   à  la
    version. Indispensable dans les phases de développement
  \item   \c{KERNEL_GZIP}:   Permet    de   choisir   le   type   de
    compression.  Chaque  algorithme  a  ces  inconvénients  et  ses
    intérêts. 
    % (cf. \url{http://free-electrons.com/blog/lzo-kernel-compression})
  \item \c{SWAP}: Permet de gérer un espace d'échange dur un disque
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Configuration globale}
  \begin{itemize} 
  \item   \c{SYSVIPC} et  \emph{MQUEUE}:   Communication  interprocessus
    définis par Posix
  \item \c{IKCONFIG}: Embarque le \file{.config} dans le noyau 
  \item \c{EXPERT}  et \c{EMBEDDED} Débloque  les options permettant
    principalement de  réduire la taille du noyau  en supprimant des
    modules importants
  \item \c{CC_OPTIMIZE_FOR_SIZE}: Compile avec \c{-Os}
  \item \c{KPROBES}, \c{PERF_EVENTS}, \c{PROFILING}, \c{GCOV_KERNEL}:
    Active les différentes instrumentation du noyau
  \end{itemize} 
\end{frame}

\begin{frame}[fragile=singleslide]{Les périphériques de block}
  \c{MODULES}: Active la gestion des modules
  \\[2ex]
  \c{BLOCK}: Il est possible  de désactiver la gestion des périphérique
  de block si votre système n'utilise que de la mémoire flash.
  \begin{itemize} 
  \item \emph{IO  Schedulers}: Permet de choisir  un ordonnanceur d'E/S
    différent de celui proposé en standard
  \end{itemize} 
  \emph{System type}:
  \begin{itemize} 
  \item Permet de choisir le type d'architecture et de chipset
  \item Il est  possible de désactiver certains cache  lors des phases
    de développement
  \item Vous trouverez  aussi dans ce menu les  options relative au jeu
    d'instructions accepté
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Options de l'horloges}
  \emph{Kernel features}
  \begin{itemize} 
  \item \c{HZ} (pas sur  ARM): Définit l'interval de réordonnancement
    de l'ordonnanceur.  Plus cette valeur est forte, plus l'overhead
    introduit par  le changement de  contexte est important  et plus
    les temps de r'éponse des tâches est court
  \item \c{NO_HZ}:  Permet de  rendre la période  de réordonnancement
    des  tâches dynamique. Devrait  permettre un  léger gain  de CPU
    (finalement négligeable  avec l'ordonnanceur en  $o(1)$). Permet
    surtout de gagner en consommation électrique.
  \item   \c{HIGH_RES_TIMER}:  Gère  les   timers  avec   une  horloge
    différente de l'ordonnanceur (l'horloge  est alors géré comme un
    périphérique  à  part).  Permet  d'obtenir  une  bien  meilleure
    précision  sur  les  mesure  de  temps, à  condition  que  votre
    matériel possède une horloge \emph{HighRes}.
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{Options de l'ordonnanceur}
  \begin{itemize} 
  \item  \emph{Preemption Model}: Permet  d'activer la  préemption du
    noyau. Le pire temps réponse sont améliorés, mais le temps moyen
    est généralement moins bon.  Un noyau préemptif stresse beaucoup
    plus  de code.   Ne  pas  activer si  vous  utlisez des  drivers
    extérieur non garanti pour cette option.
  \item  \c{RT_PREEMPT}   (sur  certaines  architectures  seulement):
    Permet de  threader les IRQ  et ainsi de remplacer  les spinlock
    par des  mutex.  Ajoute un protocole d'héritage  de priorité aux
    mutex.  Le   kernel  devient  alors   totalement  préemptif.   A
    n'utilisez  que lors  d'application temps  réelle.   Etudier des
    solutions à base d'hyperviseurs.
  \item Ne confondez  pas la préemption du noyau  avec la préemption
    des tâches utilisateur.
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{Option de gestion de la mémoire}
  \begin{itemize} 
  \item \c{EABI},  \c{OABI}, etc... : Différentes  format d'appel des
    fonctions. Spécifique à ARM (mais très important)
  \item  \emph{Memory Model}: Permet  de gérer  les futurs  systèmes à
    mémoire asymétriques entre les CPU
  \item  \c{COMPACTION}: Permet  de  compresser les  page de  mémoire
    plutôr que  les mettre en swap. Particulièrement  utile dans les
    systèmes sans swap !
  \item  \c{KSM}: Permet  de  fusionner les  page mémoire  identiques.
    Uniquement   utile   avec   des   machines   virtuelles   ou   des
    chroot. Sinon, les  noyau sait que le fichier  est déjà en mémoire
    et ne duplique pas la page
  \end{itemize} 
\end{frame}

\begin{frame}[fragile=singleslide]{Configuration du boot et du FPE}
  \emph{Boot options}:
  \begin{itemize}
  \item \c{USE_OF}: Utilise  \emph{OpenFirmware}, le nouveau format de
    description matériel appelé aussi \emph{Flatten Device Tree}
  \item  \c{CMDLINE}: Permet de  passer des  paramètres par  défaut au
    noyau (nous verrons cela un peu plus loin)
  \item \c{ZBOOT_*}:  Permettent de démarrer  le noyau à  partir d'une
    ROM, d'une MMC, etc...
  \item  \c{XIP_KERNEL}: Permet  d'executer un  noyau non  compressé à
    partir d'une ROM
  \end{itemize}
  \emph{Floating point emulation}: Si  une instruction sur des nombres
  à virgule flottante est rencontrée  et ne peut pas être éxecutée, le
  kernel peut alors émuler l'instruction (voir aussi \c{-msoft-float})
\end{frame}

\begin{frame}[fragile=singleslide]{Configuration réseau}
  \emph{Networking}:
  \begin{itemize}
  \item Possibilité d'activer les innombrables protocoles réseaux de
    niveaux 1, 2 et 3
  \item  \emph{Network options}: Beaucoup  de fonctionnalité  réseau :
    client dhcp, bootp, rarp, ipv6, ipsec, les protocole de routage,
    gestion de QoS, support des VLAN, du multicast,
  \item \c{UNIX}: Les sockets \emph{UNIX} (cf. sortie de \c{netstat})
  \item \c{INET}: Les sockets bien connue \emph{TCP/IP}
  \item \c{NETFILTER}: Le  firewall de Linux.  D'innombrable options.
    Permet  l'utilisation d'iptables  si  l'option \c{IPTABLES}  est
    active.
  \end{itemize} 
\end{frame}

\begin{frame}[fragile=singleslide]{Configuration des File systems}
  \emph{File systems}:
  \begin{itemize}
  \item  \c{EXT2_FS},   \c{EXT3_FS},  \c{EXT4_FS}: Le   file  system
    standard de Linux
  \item \c{FUSE_FS}:  Permet de développer  des file systems  en user
    space
  \item   \emph{Pseudo  filesystems}   File  systems   sans  supports
    physiques
    \begin{itemize} 
    \item \c{TMPFS}: File system  volatile en RAM.  Très utilisé avec
      des système en flash vu que  l'accès à la Flash est couteux en
      temps et destructeur pour la flash
    \item \c{SYSFS} et \c{PROC_FS}: Permettent au noyau d'exporter un
      certain nombre  de donnée  interne vers le  userland. Beaucoup
      d'outils système tirent  lors informations de ces filesystems.
      Ils doivent  être monté dans \c{/sys}  et \c{/proc}. \c{/proc}
      est plutôt  orienté processus  alors que \c{/sys}  est orienté
      modules et paramètrage du noyau.
    \end{itemize} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Configuration des File systems}
  \begin{itemize}
\item \emph{Miscellaneous  filesystems} Contient des  file systems
    spécifiques
    \begin{itemize} 
    \item \c{ECRYPT_FS}: Gestion transparent d'un file system codé
    \item  \c{JFFS2_FS}: Spécialisé  pour les  Flash avec  gestion de
      l'écriture uniforme, des bad blocks et des erase blocks.
    \item \c{CRAMFS}: Spécialisé pour ROM sans accès en écriture. 
    \item  \c{SQUASHFS}: Idem \c{CRAMFS} mais fortement compressé
    \end{itemize} 
  \item \emph{Network File Systems}
    \begin{itemize}
    \item \c{NFS_FS}:  File system  sur ethernet.  Très  utilisé dans
      l'embarqué durant les phases de développement
    \item \c{ROOT_NFS}: Permet de démarrer le noyau sur une partition
      NFS
    \end{itemize} 
  \end{itemize} 
\end{frame}

\begin{frame}[fragile=singleslide]{Configuration des Drivers}
  \emph{Device Drivers} Des centaines de drivers. Notons:
  \begin{itemize}
  \item   \c{UEVENT_HELPER_PATH}:  Le  programme   appellé  lorsqu'un
    nouveau            périphérique            est           détecté
    (cf.              \c{/proc/sys/kernel/hotplug}             et
    \c{/sys/kernel/uevent_helper})
  \item   \c{DEVTMPFS}:  Un   tmpfs  spécifique   pour   les  devices
    automatiquement  monté sur  \file{/dev}.  Les  file  device sont
    alors   automatiquement  créés   sans   l'aide  d'un   programme
    extérieur. (nous y reviendrons)
  \item \c{MTD}: Les flashs
  \item \c{STAGING}: Des drivers en cours de beta 
  \end{itemize} 
\end{frame}

\begin{frame}[fragile=singleslide]{Configuration du noyau}
  Mais aussi:
  \begin{itemize} 
  \item \emph{Kernel  Hacking}:  Options  concernant le  débugging  du
    noyau. Nous y reviendrons dans la section Debug
  \item  \emph{Security  Options}:  Plusieurs framework  permettant  de
    gérer des  droits plus  fin sur les  programmes executés  et/ou de
    garantir l'intégrité des donnée à l'aide de TPM.
  \item   \emph{Cryptographic   API}:   Fonctions   de   cryptographies
    selectionnées     automatiquement     par     d'autres     modules
    (particulièrement les protocoles réseaux)
  \item  \emph{Library routines}: Idem  \emph{Cryptographic API}  mais
    avec principalement des calculs de checksum.
  \end{itemize} 
\end{frame}

%%% ICI
% Ajouter slide au sujet du boot tftp puis nfs
\begin{frame}[fragile=singleslide]{Boot par tftp/nfs}
  Pour le développement du noyau, il est commun d'utiliser les technologies :
  \begin{itemize} 
  \item \emph{tftp}: Il s'agit  d'un protocole de transfert de fichier
    très simple. Beaucoup de bootloader l'implémentent. Il s'agit d'un
    démarrage  rapide d'un  nouveau  noyau lors  du développement.  On
    pourra aussi trouver des protocole sur RS232 ou sur USB permettant
    la même fonctionnalité. Comme pour un démarrage normal, on indique
    au bootloader  à quelle addresse le  noyau doit être  chargé et on
    \emph{jump} à cette addresse
  \item \emph{nfsroot}:  On demande au  noyau de monter  une partition
    réseau. On  dispose ainsi d'un  espace de stockage illimité  et il
    est simple et rapide de mettre à jour le rootfs.
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Notre cas}
  Dans notre cas, nous utilisons U-Boot (standard)
  \begin{itemize}
  \item Compilation
    \begin{lstlisting}
host% apt-get install uboot-mkimage
host$ make O=build ARCH=arm usb-a9260_defconfig
host$ make O=build ARCH=arm CROSS_COMPILE=arm-linux- -j3 uImage
    \end{lstlisting}
  \item Partage de l'image par TFTP
    \begin{lstlisting}
host% cp build/arch/arm/boot/uImage /srv/tftp/uImage-2.6.33.7
host% ln -s uImage-2.6.33.7 /srv/tftp/uImage
    \end{lstlisting} % $ 
  \item  Au   redémarrage,  le   bootloader  passe  par   un  registre
    l'identifiant  de   la  carte.   Cet   identifiant  (spécifique  à
    l'architecture ARM) est erroné. A  ce stade, il est plus facile de
    corriger   ce   problème   dans   le   noyau   dans   le   fichier
    \file{arch/arm/tools/mach-types}.
    \note[item]{C'est mieux de compiler avec -j3}
    \note[item]{Il faut les laisser démarrer en NFS}
    \note[item]{Il faut  commenter la ligne  1108 et changer  la ligne
      1700}
  \end{itemize}
\end{frame}

% Parler de la structure du rootfs

\section{Options de démarrage}
  % La commandline
  % √  init
  % √  root
  % √  ip
  % √  root=/dev/nfs
  % √  console
  %    panic
  %    memarea
  %    mem
  % √  <module>.<option>
\begin{frame}[fragile=singleslide]{Passage d'options au noyau}
  \begin{itemize} 
  \item Il est possible de passer des options au démarrage du noyau
  \item C'est  normalement le bootloader  qui se charge de  passer la
    ligne de commande au noyau
  \item Le bootloader utilise  un protocole prédéfini (lorsqu'il donne
    la  main au noyau,  un des  registre contient  un pointeur  sur la
    ligne de commande)
  \item Il est possible de surcharger  la ligne de commande lors de la
    compilation avec l'option \c{CMDLINE}
  \item   Les   diverses   options   acceptées   sont   décrites   dans
    \file{Documentation/kernel-parameters.txt}
  \item  Il est possible  d'accèder à  la ligne  de commande  après le
    démarrage dans \c{/proc/cmdline}
  \item Il existe  des paramètres globaux au kernel  et des paramètres
    spécifiques à  un module.  Lorsque le module  est compilé  dans en
    statique, il  est possible  de lui passer  des parametres  avec la
    syntaxe \c{<MODULE_NAME>.<PARAM>=<VALUE>}
  \item Beaucoup d'options sont modifiable à posteriori par \c{/sys}
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Le rootfs}
  \begin{itemize}
  \item \c{root=} indique le disque  à monter sur \c{/}
  \item Surement l'option la plus utilisée
  \item  Il est  possible de  spécifier  le nom  d'une partition.  Par
    exemple  \c{root=/dev/sda1} (PC) ou  \c{root=/dev/mtd0} (partition
    flash)
  \item \c{root=/dev/nfs} demande au noyau de démarrer sur NFS
  \item Remarque:  la partition \c{/}  n'étant pas encore  montée, ces
    nom  de partition ne  correspondent pas  à des  fichiers existants
    dans \c{/dev}. Le kernel utilise simplement la même syntaxe.
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{La configuration réseau}
  \begin{itemize}
  \item Il est posisble d'initialiser le réseau avant de montage du rootfs
  \item Indispensable pour le démarrage par NFS
  \item Syntaxe: \c{ip=<client-ip>:<server-ip>:<gw-ip>:<netmask>:<hostname>:<device>:<autoconf>} 
  \item Exemple: \c{ip=192.168.1.72:::::eth0:}
  \item  Pour  le  démarrage  par  nfs, il  est  aussi  nécessaire  de
    spécifier    le    répertoire     partagé    par    le    serveur:
    \c{nfsroot=192.168.1.10:/srv/nfs}
  \item  Il aussi possible  de démarrer  en utilisant  un DHCP  (ou un
    autre protocole d'autonégociation): \c{ip=on}
  \end{itemize}
\end{frame} 

\begin{frame}[fragile=singleslide]{La configuration réseau}
  \begin{itemize} 
  \item  Il est  alors possible  de spécifier  le \c{nfsroot}  dans la
    configuration du serveur DHCP:
     \begin{lstlisting} 
host target {
    option root-path "192.168.1.10:/srv/nfs";
    next-server 192.168.1.10;
    hardware ethernet 00:26:24:3a:14:5c;
   fixed-address 192.168.1.72;
}
     \end{lstlisting} 
   \item  Lors du  démarrage NFS,  attention aux  modifications  de la
     configuration réseau postérieure au montage du rootfs
    \item Référence: \file{Documentation/filesystems/nfs/nfsroot.txt}
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Démarrage du noyau}
  \begin{itemize}
  \item  A  la fin  du  démarrage  du noyau,  celui  donne  la main  à
    l'éxecutable déclaré  avec \verb+init=+. Par défaut,  il s'agit de
    \file{/sbin/init}
  \item \cmd{init} ne se termine jamais
  \item  Les  arguments  nons  utilisés  par le  noyau  sont  passé  à
    \cmd{init}
  \item On peut  estimer que notre système démarre  à partir du moment
    ou nous  obtenons un shell (c'est  en tous cas  la que la
      plupart des intégrateur Linux embarqué s'arreterons)
  \item Du moins complexe au plus complexe à démarrer:
  \begin{itemize}
    \item \verb+init=/hello-arm-static+
    \item \verb+init=/hello-arm+
    \item \verb+init=/bin/sh+
    \item \verb+init=/sbin/init+
    \end{itemize}
  \end{itemize}
  Effectuons ces tests avec le Rootfs original et un Rootfs vierge.
\end{frame}

\begin{frame}[fragile=singleslide]{La console}
  \begin{itemize} 
    \item Surement la deuxième option la plus utilisée
    \item  \c{console=}  permet de  demander  au  noyau d'afficher  la
      sortie de \c{printk} sur un périphérique spécifique.
    \item Sur PC, souvant limité à \c{console=ttyS0,115200n8}.
    \item Sur  un système  embarqué, il existe  beaucoup de  driver de
      ports  séries différents.   \c{console} peut  alors  prendre des
      valeurs exotiques. A voir au cas par cas pour chaque driver.
  \end{itemize} 
\end{frame} 

  %   mem
  %   memmap
\begin{frame}[fragile=singleslide]{La mémoire}
  \begin{itemize} 
  \item Il est parfois nécessaire  de donner des instruction au kernel
    sur l'utilisation qu'il peut faire des espaces mémoires
  \item \c{mem=nn}  Force la  taille de la  mémoire que le  noyau peut
    utiliser. Sur beaucoup de  plateformes, le noyau n'est pas capable
    de détecter la capacité de la mémoire.
  \item  \c{memmap=nn@ss}   et  \c{memmap=nn$ss}  Force   le  noyau  à
    n'utiliser que la mémoire entre \c{ss} et \c{ss+nn}
  \item \c{memmap=nn@ss}  et \c{memmap=nn$ss} Force le noyau  à ne pas
    utiliser la mémoire entre \c{ss} et \c{ss+nn}
  \item Il est possible d'utiliser plusieurs fois ces options
  \item Utiles pour rapidement réservés des espace d'adresse d'E/S pas
    encore défini  dans la configuration  ou se réserver des  block de
    mémoire   particuliers  pour   la   communication  avec   d'autres
    périphériques
  \end{itemize}
\end{frame}

  % Fabriquer un initramfs
\section{Initramfs}

\begin{frame}[fragile=singleslide]{Initramfs}
  \begin{itemize}
  \item Qu'est-ce qu'un initramfs?
  \item Un petit filesystème chargé en mémoire par le bootloader
  \item Successeur de initrd (plus complexe d'utilisation)
  \item Permet déffectuer des actions avant le lancement d'init
  \item Il devrait rester petit et ne s'utiliser que pour continuer le
    boot
  \item  Si  vous  intégrez  busybox  dans  votre  initramfs,  il  est
    préconisé  de  le compiler  en  statique  en  ne gardant  que  les
    composant utiles
  \item  Cas classique:  charger les  modules permettent  d'acceder au
    filesystème:
    \begin{itemize}
    \item M-Sys Disc-On-Chip
    \item Configuration RAID
    \item Configuration réseau pour booter en NFS
    \end{itemize}
  \item Dans notre cas, il n'est pas utile car nous n'avons pas besoin
    de charger de driver particuliers avant le démarrage
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{Initramfs}
  \begin{itemize} 
  \item Création d'un rootfs vraiment minimal:
    \begin{lstlisting}[language=sh]
host$ mkdir initramfs
host$ cd initramfs
host$ mkdir dev
host$ mknod dev/console c 5 1
host% cp .../hello-arm-static init
host$ find . |  cpio -o | gzip > initramfs.gz
    \end{lstlisting} %$
  \item Comme l'image noyau, l'image initramfs doit être au format u-boot.
    \begin{lstlisting} 
host$ mkimage -A arm -T ramdisk -d initramfs.gz initramfs.gz.img
host$ cp initramfs.gz.img /srv/tftp
uboot> tftp 4000000 initramfs.gz.img
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Initramfs}
  \begin{itemize} 
  \item  On  indique  l'adresse   du  ramfs  en  second  paramètre  de
    \cmd{bootm}. Evidement, le noyau doit être configuré pour utiliser
    le ramfs.
    \begin{lstlisting} 
uboot> setenv autostart no
uboot> tftp 22000000 initramfs.gz.img 
uboot> tftp 21000000 uImage 
uboot> bootm 21000000 22000000 
    \end{lstlisting}
  \end{itemize}
  \note[item]{TODO P1 A verifier, tester, completer}
\end{frame}


\begin{frame}[fragile=singleslide]{Etape de fabriquation d'un BSP}
  \begin{itemize}
  \item  Commencez par compiler  une toolchain  si celle-ci  n'est pas
    fournie.
  \item  Si le  bootloader est  fourni, travaillez  avec  celui-ci. Il
    arrive souvent que les bootloader initialisent certains paramètres
    du CPU sans lesquel le kernel ne peut démarrer
  \item Si  vous n'avez pas  de bootloader, vous devrez  commencez par
    paramètrer une sonde JTAG
  \item  Sinon, vous  pouvez développer  le  noyau et  le bootload  en
    parallèle. Sans  bootloader, vous  devrez utiliser une  sonde JTAG
    pour démarrer votre cible
  \item  Configurer   le  noyau  jusqu'à   pouvoir  démarrer  l'espace
    utilisateur
  \item Compiler un busybox pour l'espace utilisateur
  \item Faites fonctionner les différents périphériques
  \item Intégrer  votre toolchain,  votre bootloader, les  fichiers de
    configuration de  votre noyau et  de votre busybox, vos  outils et
    drivers spécifique dans un outil tel que BuildRoot
  \item Zipper l'ensemble
  \item Compilez l'ensemble et zipper le résultat
  \item Intégrez vos modification dans l'upstream
  \end{itemize}
\end{frame} 




