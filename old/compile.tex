% This document is available under the Creative Commons Attribution-ShareAlike
% License; additional terms may apply. See
%   * http://creativecommons.org/licenses/by-sa/3.0/
%   * http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
% Copyright 2010 Jérôme Pouiller <jezz@sysmic.org>
%

\part{Créer}

\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \tableofcontents[currentpart]
\end{frame}

\section{Booter par réseau}

\begin{frame}{Booter par réseau}
  \begin{itemize}
  \item Permet de travailler  plus confortablement car evite les cycles
    de scp/flash
  \item Parfois, il faut demarrer  la cible sous Linux pour pouvoir la
    flasher.  C'est donc la seule manière de continuer.
  \item Fonctionne aussi très bien avec des PC
  \item Trois étapes pour démarrer un système
    \begin{enumerate}
    \item Le bootloader configure la carte réseau et place le noyau en
      mémoire
    \item Le noyau s'execute et monte un filesystem réseau
    \item Le premier processus de la vie du système est lancé: \cmd{init}
    \end{enumerate}
    \end{itemize}
\end{frame}

\subsection{Le bootloader}

\begin{frame}[fragile=singleslide]{Le bootloader}{Description}
  \begin{itemize}
  \item    Le    bootloader     se    trouver    souvent    sur    une
    \emph{eeprom}.  Celle-ci   est  directement  mappée   sur  le  bus
    d'adresse
  \item Au minimum, il doit initialiser:
    \begin{itemize}
    \item les timing de la mémoire RAM
    \item les caches CPU
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Le bootloader}{Description}
  \begin{itemize}
  \item Il peut :
    \begin{itemize}
    \item Initialiser une ligne série pour l'utiliser comme terminal
    \item Offrir un prompt et accèder à des options de boot
    \item Initialiser la mémoire flash
    \item Copier le noyau en mémoire
    \item Passer des arguments au noyau
    \item Initialiser le chipset réseau
    \item  Récupérer  des  informations  provenant d'un  serveur  DHCP
      (serveur où récupérer l'image du noyau, indications sur les mise
      à jour disponibles, etc...)
    \item Lire des fichiers provenant du réseau
    \item Lire des fichier par \verb+{X,Y,Z}MODEM+
    \item Ecrire sur la flash
    \item Gérer un système de secours
    \item  Initialiser des  fonctionnalités  cryptographiques (Trusted
      Plateform Manager)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Le bootloader}{Description}
  \begin{itemize}
    \item Il  est très  rare de pouvoir  démarrer Linux  sans bootloader
    fonctionnel
    \item Si votre bootloader  n'est pas fonctionnel, vous aurez souvent
    besoin d'un matériel particulier pour  le mettre à jour (un outils
    capable de flasher l'eeprom)
  \end{itemize}
  Bootloader connus:
  \begin{itemize}
    \item Grub
    \item Syslinux (et son dérivé Isolinux)
    \item U-Boot (utilisé ici)
    \item Redboot
    \item BareBoot (successeur de U-Boot)
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Le bootloader}{Test}
  Testons notre bootloader:
  \begin{itemize}
    \item Démarrez minicom
    \begin{lstlisting}
host$ minicom -D /dev/ttyUSB1
    \end{lstlisting}
  \item Resettez la carte
  \item Appuyez sur une touche pour stopper le démarrage
    \begin{lstlisting}
[...]
Hit any key to stop autoboot:  0
    \end{lstlisting}
  \item Obtenez la liste des commandes
    \begin{lstlisting}
uboot> help
    \end{lstlisting}
  \end{itemize}
  Attention:
  \begin{itemize}
  \item Pas d'historique
  \item Pas de flèches gauche/droite
  \end{itemize}
  En  cas de  problème pour  vous connecter,  vérifiez  vos paramètres
  RS232.
\end{frame}

\subsection{TFTP}

\begin{frame}[fragile=singleslide]{TFTP}{Mise en place}
  \begin{itemize}
  \item Identique au protocole \cmd{ftp} mais plus simple
  \item Permet d'etre implémenté avec très peu de ressource
  \item Mise en place:
    \begin{lstlisting}
host% apt-get install atftp atftpd
host% cp hello/build-arm/hello /srv/tftp
    \end{lstlisting}
  \item Test en local
    \begin{itemize}
    \item Par le shell interactif
      \begin{lstlisting}
host$ atftp 127.0.0.1
> get hello
> exit
      \end{lstlisting}
    \item Par la ligne de commande
      \begin{lstlisting}
host$ atftp 127.0.0.1 -g -r hello
      \end{lstlisting} % $
    \end{itemize}
    \note[item]{Il est possible de parler de inetd et /etc/default/atftpd}
  \item En cas de  problème, consultez les logs (\file{/var/log/syslog}
    ou \file{/var/log/daemon.log})
% A priori, ca n'est plus vrai avec les nouvelles version:
%     \item Remarque: chemin absolu, pas de cd, etc...
%       \begin{lstlisting}
% host$ scp root@target:/.../uImage /var/lib/tftpboot
% host$ atftp 127.0.0.1 -g -l /var/lib/tftpboot/uImage # Test
%       \end{lstlisting}
  \item En  cas d'utilisation intensive (déploiement  sur des milliers
    de  systèmes),  vous   pouvez  utiliser  \cmd{atftpd}  de  manière
    autonome (voir \file{/etc/default/atftpd})
  \item  Il  est  possible  de  modifier le  répertoire  partagé  dans
    \file{/etc/inetd.conf} ou dans \file{/etc/default/atftpd} (suivant
    le mode d'éxecution)
    \note[item]{Parler de inetd}
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{TFTP}
  \note[item]{Il faut fournir le noyau pré-compilé ou le noyau Calao}
  Configuration de la cible pour télécharger et démarrer le noyau. Par RS232:
  \begin{itemize}
  \item Configuration de l'IP
    \begin{lstlisting}
uboot> setenv ipaddr 192.168.1.12
    \end{lstlisting}
  \item Vérification la configuration IP
    \note[item]{U-boot n'est  pas assez évolué pour  répondre aux ping
      (ca nécessite un service qui tourne en arrière plan ce qui n'est
      pas souhaitable pour faire du debug de bas niveau)}
    \begin{lstlisting}
uboot> ping 192.168.1.10
    \end{lstlisting}
  \item Déclaration de notre \emph{host} comme serveur \cmd{tftp}
    \begin{lstlisting}
uboot> setenv serverip 192.168.1.10
uboot> saveenv
    \end{lstlisting}
    \note[item]{Eventuellement,   rebooter  après   le   saveenv  pour
      initialiser correctement le réseau}
  \item Téléchargement du noyau dans une zone libre de la mémoire
    \note[item]{Expliquer d'où provient 21000000}
    \note[item]{L'adresse de  chargement du noyau  dépend de plusieurs
      parmètres: topologie  mémoire, utilisation  de la m'oire  par le
      bootloader, configuration du noyau, taille du noyau, etc..}
%    \note[item]{Reprendre   un    schéma   similaire   à    celui   de
%      \verb+http://www.at91.com/linux4sam/bin/view/Linux4SAM/GettingStarted#Linux4SAM_NandFlash_demo_Memory+
%      mais pour la RAM}
    \begin{lstlisting}
uboot> tftpboot 21000000 uImage
    \end{lstlisting}
  \item Exécution du noyau
    \begin{lstlisting}
uboot> bootm 21000000
    \end{lstlisting}
    \note[item]{Si autostart=yes, pas besoin de cette derniere ligne}
  \item Le noyau  trouve la flash, monte la flash  et charge l'init de
    la flash
    \note[item]{Exo: faites la même chose par ZMODEM}
    \note[item]{Tester avec le NFS éteind}
  \end{itemize}
\end{frame}

\subsection{NFS}

\begin{frame}[fragile=singleslide]{Nfs}
  Comparable au partage réseau de windows.
  \begin{itemize}
  \item Installation
    \begin{lstlisting}
host% apt-get install nfs-kernel-server nfs-common
host$ mkdir nfs-root 
host% vim /etc/exports
    \end{lstlisting} % $
    \note[item]{nfs-common contient le client}
    \note[item]{On peut essayer avec unfs3}
    \note[item]{Autrefois le paquet s'apellait nfs-user-serveur}
  \item Configuration du partage
    \begin{lstlisting}
/home/user/nfs-root 0.0.0.0/0.0.0.0(ro)
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Nfs}
  \begin{itemize}
    \item Test sur l'hôte
      \begin{lstlisting}
host$ service nfs-kernel-server restart
host$ mkdir nfs-mount
host% mount -t nfs 127.0.0.1:/home/user/nfs-root nfs-mount
      \end{lstlisting} % $
    \item Vérification des droits root
      \begin{lstlisting}
host$ echo foo > nfs-root/file
host$ chmod 000 nfs-root/file
host$ ls -l nfs-mount
host% cat nfs-mount/file
      \end{lstlisting} % $
      \note[item]{ Le  test sur la cible  ne fonctionne que  si les binaires
        necessaires sont installée}
     \item Test sur la cible (nécessite le support de NFS dans \cmd{mount})
       \begin{lstlisting}
target$ mkdir nfs-mount
target% mount -t nfs 192.168.1.10:/home/user/nfs-root nfs-mount
       \end{lstlisting} % $
     \item En cas de problème, vérifiez les logs: \file{/var/log/daemon.log}
   \end{itemize}
\end{frame}  

%    \note[item] {Ca permet de ne pas leur donner le rootfs. Est-ce qu'on garde?}
%    \note[item] {C'est une très mauvaise idée de dumper une partition montée}
%    \note[item] {Il faut mieux leur faire faire cette manip dans la section sur les MTD}
%     \item Obtenir une copie conforme de la cible
%       \begin{lstlisting}
% target% tar cv / | tftp host -p -l - -r /srv/tftp/root.tar
% host$ gzip /srv/tftp/root.tar
%       \end{lstlisting} % $
\begin{frame}[fragile=singleslide]{Démarrage sur le NFS}
  \begin{itemize}
  \item Modification des arguments passés au noyau
    \note[item]{Testé avec 3e83c0851c2f1483ef92ce845e6f27e3 uImage, du
      site de Calao}
    \note[item]{Testé       avec      50ddb3a654f5e56e3fa1a70216abbb5e
      rootfs.arm.jffs2 du site de Calao}
    \begin{itemize}
    \item Configuration IP
      \begin{lstlisting}
uboot> setenv ipconf ip=192.168.1.13:192.168.1.10:192.168.1.254:255.255.255.0:target:eth0:off
      \end{lstlisting}
    \item Configuration NFS
      \begin{lstlisting}
uboot> setenv nfsconf root=/dev/nfs nfsroot=/home/user/nfs-root
      \end{lstlisting}
    \item La variable \cmd{bootargs} permet de passer des arguments au noyau
      \begin{lstlisting}
uboot> setenv bootargs ${ipconf} ${nfsconf} panic=1
      \end{lstlisting}
    \item Démarrage
      \begin{lstlisting}
uboot> boot
      \end{lstlisting}
    \end{itemize}
  \item Voir \file{Documentation/filesystem/nfs/nfsroot.txt}
  \item Après avoir monté le NFS, le noyau essaye de passer la main au
    programme \cmd{init}
  \end{itemize}
\end{frame}

\section{Compilation des differents éléments}

\subsection{Compilation du noyau}

\begin{frame}[fragile=singleslide]{Récupération des sources}
  Ou récupérer les sources du noyau?
  \begin{enumerate}
  \item Utiliser  les sources souvent fournies.  Il arrive souvent
    qu'elles  contiennent  des  drivers particuliers  et  qu'elles
    soient déjà configurées
  \item Utiliser \cmd{git clone} (nous y reviendrons)
  \item Télecharger sur \file{kernel.org}
  \end{enumerate}
  \note[item]{Fonctionne aussi avec 2.6.37}
  \begin{lstlisting}
host$ wget http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.33.7.tar.bz2
host$ tar xvjf linux-2.6.33.7.tar.bz2
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide]{Interface de configuration du noyau}
  \begin{itemize}
    \item Utilise Kconfig
      \begin{lstlisting}
host$ make help
host$ mkdir build
host$ make O=build ARCH=arm CROSS_COMPILE=arm-linux- menuconfig
       \end{lstlisting}
     \item  Beaucoup d'options,  mais il  y a  l'aide (\verb+<h>+)  et la
       recherche (\verb+</>+)
    \item La configuration est sauvée dans \file{.config}
    \item    \verb+usb-a9260_defconfig+   permet   de    charger   une
      configuration pré-établie pour notre carte
      \begin{lstlisting}
host$ make O=build ARCH=arm CROSS_COMPILE=arm-linux- usb-a9260_defconfig          
      \end{lstlisting}
    \begin{itemize}
    \item Certains constructeur vous  fournirons un patch ajoutant une
      cible \verb+_defconfig+
    \item D'autre vous fournirons un \file{.config}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Options à connaitre}
  \begin{itemize}
  \item Kernel Compression (Gzip/LZO)
  \item Support for paging of anonymous memory (swap)
  \item Kernel .config support
  \item Kernel log buffer size
  \item Group CPU scheduler
  \item Initial RAM filesystem and RAM disk
  \item Optimize for size
  \item Configure standard kernel features (for small systems)
  \item EXecute In Place
  \end{itemize}
  \note[item]{TODO P3 faire une liste exaustive}
\end{frame}

\begin{frame}[fragile=singleslide]{Compilation du noyau}
  \begin{itemize}
  \item Verifier les options du type de processeur
  \item Cocher NFS
  \item Le reste ne devrait pas empecher ce demarrer votre cible
  \item La compialtion se lance avec
    \begin{lstlisting}
host$ make XXImage
    \end{lstlisting}
  \item \verb+XX+ fait reference au format de la binaire produite:
    \begin{itemize}
    \item Le premier octet est-il du code?
    \item Respecte-t-il le format ELF?
    \item Y a-t-il un format particulier d'entête à respecter ?
    \end{itemize}
  \item Dans  le doute,  il faut consulter  la documentation  de votre
    bootloader
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{Compilation du noyau}
  Fichiers produits (ou productibles) par la compilation:
  \begin{itemize}
  \item  \verb+vmlinux+:  L'image  ELF  du  noyau.   Lisible  par  les
    debugueurs, certains flasheurs, certain bootloaders
  \item  \verb+vmlinuz+: parfois  équivalent  du \verb+bzImage+,  mais
    normalement, il  s'agit de\verb+vmlinux+ compressé  et strippé des
    informations inutiles  au démarrage. Inutilisable  dans l'état, il
    est nécéssaire de lui adjoindre un bootloader pour le décompresser
    et l'éxecuter.
  \item  \verb+Image+:  \verb+vmlinux+   strippé  et  préfixé  par  un
    mini-bootloader   permettant    de   sauter   sur    la   fonction
    \verb+start_kernel+ de \verb+vmlinux+.
  \item  \verb+bzImage+  et   \verb+zImage+:  \verb+vmlinuz+  avec  le
    bootloader \cmd{bz2} ou \cmd{gz}.
  \item  \verb+xipImage+  :  Idem  \verb+Image+ mais  destiné  à  être
    éxecuté  directement  sur un  \emph{eeprom}  sans  être copier  en
    mémoire au préalable.
  \item  \verb+uImage+:  \verb+Image+ avec  une  entête spéciale  pour
    \emph{u-boot}.
  \end{itemize}
  Il est possible  de générer des image au  format SRecord en utiliant
  \cmd{objcopy}
  \begin{lstlisting}
host$ objcopy -O srec vmlinux vmlinux.srec
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler le noyau}
  Dans notre cas, nous utilisons U-Boot (standard)
  \begin{itemize}
  \item Compilation
    \begin{lstlisting}
host% apt-get install uboot-mkimage
host$ make O=build ARCH=arm CROSS_COMPILE=arm-linux- uImage
    \end{lstlisting}
  \item Partage de l'image par TFTP
    \begin{lstlisting}
host% cp build/arch/arm/boot/uImage /srv/tftp/uImage-2.6.33.7
host% ln -s uImage-2.6.33.7 /srv/tftp/uImage
    \end{lstlisting} % $ 
  \item  Au   redémarrage,  le   bootloader  passe  par   un  registre
    l'identifiant  de   la  carte.   Cet   identifiant  (spécifique  à
    l'architecture ARM) est erroné. A  ce stade, il est plus facile de
    corriger   ce   problème   dans   le   noyau   dans   le   fichier
    \file{arch/arm/tools/mach-types}.
    \note[item]{C'est mieux de compiler avec -j3}
    \note[item]{Il faut les laisser démarrer en NFS}
    \note[item]{Il faut  commenter la ligne  1108 et changer  la ligne
      1700}
  \end{itemize}
  \note{Parler de l'installation des modules et de l'option INSTALL\_MOD\_PATH}
\end{frame}


\subsection{Création de l'init}

\begin{frame}[fragile=singleslide]{Démarrage du noyau}
  \begin{itemize}
  \item  A  la fin  du  démarrage  du noyau,  celui  donne  la main  à
    l'éxecutable déclaré  avec \verb+init=+. Par défaut,  il s'agit de
    \file{/sbin/init}
  \item \cmd{init} ne se termine jamais
  \item  Les  arguments  nons  utilisés  par le  noyau  sont  passé  à
    \cmd{init}
  \item On peut  estimer que notre système démarre  à partir du moment
    ou nous  obtenons un shell (c'est  en tous cas  la que la
      plupart des intégrateur Linux embarqué s'arreterons)
  \item Du moins complexe au plus complexe à démarrer:
  \begin{itemize}
    \item \verb+init=/hello-arm-static+
    \item \verb+init=/hello-arm+
    \item \verb+init=/bin/sh+
    \item \verb+init=/sbin/init+
    \end{itemize}
  \end{itemize}
  Effectuons ces tests avec le Rootfs original et un Rootfs vierge.
\end{frame}

\begin{frame}[fragile=singleslide]{Créer l'espace utilisateur}{Créer l'arborescence}
  Nous travaillerons dans un répertoire vierge
  \begin{lstlisting}
host$ mkdir nfs-root-mine
host$ cd nfs-root-mine
host$ ln -s nfs-root-mine nfs-root
  \end{lstlisting} % $
  L'arborescence classique sera:
  \vspace{-2ex}
  \begin{columns}[onlytextwidth,t]
    \begin{column}[t]{0.5\textwidth}
      \begin{itemize}
      \item bin
      \item sbin
      \item usr/bin
      \item usr/sbin
      \item etc
      \end{itemize}
    \end{column}
    \begin{column}[t]{0.5\textwidth}
      \begin{itemize}
      \item dev
      \item proc
      \item sys
      \item tmp
      \item var
      \end{itemize}
    \end{column}
  \end{columns}
  \vspace{2ex}
  Il est possible de ne pas respecter cette arborescence, mais cela
  compliquerait inutilement la chose
\end{frame}

\begin{frame}[fragile=singleslide]{Créer l'espace utilisateur}{Créer l'arborescence}
  Après le démarrage, le noyau ne trouve pas l'init:
    \begin{lstlisting}
[...]
Kernel panic - not syncing: No init found.  Try passing init= option to kernel.
    \end{lstlisting}

    Copions maintenant  \verb+hello-arm-static+ et \verb+hello-arm+ et
    essayons de démarrer avec:
    \begin{lstlisting}
[...]
Cannot open /dev/console: No such file or directory
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide]{Démarrage d'une binaire statique}
  Les fichiers devices
  \begin{itemize}
  \item Permettent de communiquer avec le noyau
  \item Il représente plus ou moins chacun un périphérique
  \item Les plus importants sont normés (\file{Documentation/devices.txt})
  \item Il est possible de les créer avec \cmd{mknod}:
    \begin{lstlisting}
host% mknod dev/console c 5 1
    \end{lstlisting}
  \item  Ce  device  est  nécessaire  pour  \cmd{printf}.   Il  serait
    possible  d'écrire un programme  ne nécessitant  aucun accès  à un
    périphérique (exemple: le service réseau echo)
  \end{itemize}
  Nous pouvons maintenant démarrer avec \verb+init=/hello-arm-static+
\end{frame}

\begin{frame}[fragile=singleslide]{Installation des bibliothèques de base}
  Les bibliothèques de base  (\cmd{libc} et apparentés) sont forcement
  fournies avec le cross-compilateur, car elles y sont intimement liés
  \begin{itemize}
  \item Liste des bibliothèques nécessaires
    \begin{lstlisting}
host$ arm-linux-ldd --root . hello-arm
    \end{lstlisting}
    \item Copie
    \begin{lstlisting}
host$ mkdir lib
host$ cp /opt/arm-linux-.../lib/ld-uClibc-0.9.30.2.so lib
host$ cp /opt/arm-linux-.../lib/libuClibc-0.9.30.2.so lib
    \end{lstlisting}
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{Installation des bibliothèques de base}
  \begin{itemize}
  \item Configuration de \cmd{ldconfig}
    \begin{lstlisting}
host$ echo /lib > etc/ld.so.conf
host$ echo /usr/lib >> etc/ld.so.conf
    \end{lstlisting}
  \item Création des liens symboliques
    \begin{lstlisting}
host$ ldconfig -r . -N
    \end{lstlisting}
  \item Création du cache. Le  cache n'est pas obligatoire, mais si il
    existe, il doit être à jour
    \note[item]{Faire un exo sur PC avec ldconfig}
    \begin{lstlisting}
host$ ldconfig -r .
    \end{lstlisting}
  \end{itemize}
  Nous pouvons maintenant démarrer avec \verb+init=/hello-arm+
\end{frame}

\subsection{Compilation de l'espace utilisateur}

\begin{frame}[fragile=singleslide]{Busybox}
  \begin{itemize}
  \item  Contient la plupart  des binaire  nécéssaire pour  démarrer un
    système
  \item Attention, ce ne  sont pas les meme outils que sur  PC. Il y a
    souvent des option non-implémentés ou des comportements différents
  \item Téléchargement
    \begin{lstlisting}
host$ wget http://busybox.net/downloads/busybox-1.18.3.tar.bz2
host$ tar xvjf busybox-1.18.3.tar.bz2
host$ mkdir build
    \end{lstlisting}
  \item On retrouve \cmd{Kconfig}
    \begin{lstlisting}
host$ make O=build CROSS_COMPILE=arm-linux- allnoconfig
host$ make O=build CROSS_COMPILE=arm-linux- menuconfig
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Busybox}
  \begin{itemize}
  \item On trouve pleins d'outils
    \note[item]{TODO: mettre en plusieurs colonnes}
  \item    Au   minimum,    cochons    \cmd{ash},   \cmd{init},    les
    \emph{Coreutils},    \cmd{dmesg},   \cmd{ifconfig},   \cmd{mount},
    \cmd{tftp}, \cmd{tar}, \cmd{reboot}, \cmd{vi}
    \note[item]{TODO: mettre en plusieurs colonnes}
  \item         Et         aussi:        \verb+CONFIG_PLATFORM_LINUX+,
    \verb+CONFIG_FEATURE_EDITING+,        \verb+CONFIG_FEATURE_DEVPTS+,
    \verb+CONFIG_LONG_OPTS+,                  \verb+CONFIG_SHOW_USAGE+,
    \verb+FEATURE_VERBOSE_CP_MESSAGE+, \verb+IOCTL_HEX2STR_ERROR+
  \end{itemize}
  \note[item]{TODO P2 Lister de manière exaustive}
\end{frame}

\begin{frame}[fragile=singleslide]{Installation de Busybox}
  \begin{itemize}
  \item Configurons le chemin de destination vers \file{../install}
    \begin{lstlisting}
host$ make O=build CROSS_COMPILE=arm-linux-
host$ make O=build CROSS_COMPILE=arm-linux- install
    \end{lstlisting}
    \note[item]{Compiler avec -j3}
  \item  L'installation créé  des  liens symboliques  vers la  binaire
    \cmd{busybox}
  \item  Sans  Busybox,  toutes  ces  binaires  seraient  séparées  et
    dispersées sur une dizaine de sources
  \item Nous pouvons maintenant démarrer avec \verb+init=/bin/sh+
    \note[item] {Démarrer avec  console=ttyS0,115200 afin d'éviter les
      problème avec le jobs: Non ca ne marche pas}
  \item \verb+init=/bin/init+ pose encore quelques problèmes.
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compilons init}{Fichiers device}
  Ajoutons  les devices  \file{/dev/tty}  (En fait,  pas  tout à  fait
  obligatoire)
  \begin{lstlisting}
host% mknod dev/ttyS0 c 4 64
host% mknod dev/tty2 c 4 2
host% mknod dev/tty3 c 4 3
host% mknod dev/tty4 c 4 4
  \end{lstlisting}
  \note[item]{tester  avec console=ttyS0,115200  et retirer  cette section : Non, ca ne marche pas}
%   \item \cmd{MAKEDEV} automatise une partie de la création des fichiers
%     devices
%     \note[item]{TODO Voir si on ne  peut pas continuer sans MAKEDEV et
%       l'introduire dans la section "Ajouts"}
%     \begin{lstlisting}
% host% cd dev
% host% MAKEDEV std
% host% MAKEDEV console
%     \end{lstlisting}
  Nous  pouvons  maintenant  démarrer avec  \cmd{init=/bin/init}  mais
  certaines fonctionnalités sont absentes (\cmd{ps}, etc... )
\end{frame}

\begin{frame}[fragile=singleslide]{Configuration de \cmd{init}}
  Il est possible de configurer \cmd{init} avec le fichier
  \file{/etc/inittab}
  \begin{itemize}
  \item Lancement automatique d'un shell
    \begin{lstlisting}
host$ echo "ttyS0::askfirst:/bin/sh" > etc/inittab 
    \end{lstlisting}
  \item Appel d'un script de démarrage.
    \begin{lstlisting}
host$ echo "::sysinit:/etc/init.d/rcS" >> etc/inittab 
host$ mkdir etc/init.d
host$ echo "#!/bin/sh" > etc/init.d/rcS
host$ chmod +x etc/init.d/rcS
    \end{lstlisting}
  \end{itemize}
  Documentation disponible sur la page de man \emph{inittab(5)}
  (disponible ici: \url{http://tfm.cz/man/5/inittab}).\\[2ex]
  Des  fichier de  configuration  de init  et  d'autres utilitaire  de
  busybox sont disponibles dans \file{busybox/examples}
  \note[item]{tester  avec console=ttyS0,115200  et retirer  "ttyS0 de
    l'inittab": Non ca ne marche pas}
\end{frame}

\begin{frame}[fragile=singleslide]{Compilons init}{Fichiers de configuration}
  Il faut monter les partitions \cmd{/proc} et \cmd{/sys}:
  \begin{lstlisting}
target% mount -t proc none /proc 
target% mount -t sysfs none /sys
  \end{lstlisting}
  Automatisation du montage avec \file{inittab}:
  \begin{lstlisting}
host$ echo "::sysinit:mount -t proc none /proc" >> etc/inittab 
host$ echo "::sysinit:mount -t sysfs none /sys" >> etc/inittab 
  \end{lstlisting}
  Nos commandes semblent maintenant correctement fonctionner.
\end{frame}

\begin{frame}[fragile=singleslide]{Autres \cmd{init}}
  Il existe d'autres formes d'\cmd{init}:
  \begin{itemize}
  \item SystemV (celui que nous utilisons)
  \item runit (aussi proposé par Busybox)
  \item upstart (utilisé par Ubuntu)
  \end{itemize}
  Ces \cmd{init},  plus moderne  offre de nouvelle  fonctionnalités et
  plus de robustesse pour le système.
\end{frame}

\begin{frame}{Et si ca ne marche toujours pas?}
  \begin{itemize}
  \item Toujours commencer par  \emph{hello-static}, le moins dépendant
  \item Si il ne fonctionne  pas, recherchez dans le format de binaire
    de  la chaîne  de compilation  et avec  sa compatibilité  avec les
    options du noyaux
  \item  Si \emph{hello-static} fonctionne,  mais pas  \emph{hello} en
    dynamique, cherchez du coté des  du format de la \emph{libc} et de
    sa compatibilité avec le format de binaire \emph{hello}
  \item Si \emph{hello} fonctionne masi  que vous ne pouvez pas lancer
    de shell, cherchez du coté des devices et des droits.
  \item Si le  shell démarre mais pas init, rechechez  du coté des des
    fichiers de configuration et des devices
  \item Vérifier que votre cible  ne change pas d'IP en démarrant (ici
    dans \file{/etc/inittab})
  \item Sinon, cherchez dans les parametres passés au noyau ou dans la
    configuration
  \item Si possible, toujours tester entre chaque modification
  \end{itemize}
\end{frame}

\begin{frame}{Résumé}
  Que contient l'espace utilisateur standard?
  \begin{itemize}
  \item une arborescence
  \item des binaires
  \item des bibliothèques
  \item des fichiers devices
  \end{itemize}
\end{frame}

\section{Quelques ajouts}
 
\subsection{\file{fstab}}

\begin{frame}[fragile=singleslide]{Utilisation de \file{fstab}}
  Il  est   possible  d'automatiser  ce  montage   au  démarrage  avec
  \file{fstab} et \cmd{mount -a}
  \begin{lstlisting}
host$ echo 'none /proc proc'  >> etc/fstab
host$ echo 'none /sys  sysfs' >> etc/fstab
target% mount -a
  \end{lstlisting}

  Nous pouvons utiliser le  fichier \file{etc/inittab} pour monter nos
  partitions automatiquement.
  \begin{lstlisting}
host$ echo "::sysinit:/bin/mount -a" >> etc/inittab 
host$ echo "::shutdown:/bin/mount -r -a" >> etc/inittab 
  \end{lstlisting}
\end{frame}

\subsection{\file{tmpfs}}

\begin{frame}[fragile=singleslide]{Filesystem temporaire}
  Créer un  filesystem en  memoire permet de  protèger notre  flash (à
  durée  de vie  limitée), de  garnatir que  nos système  est toujours
  identique entre chaque démarrage et d'améliorer les performances.
  \begin{itemize}
    \item Création
    \begin{lstlisting}
host$ mkdir tmp
    \end{lstlisting}
  \item Ajout du \emph{stickybit} comme il se doit
    \begin{lstlisting}
host$ chmod +t tmp
    \end{lstlisting}
  \item Montage d'un filesystem contenu en mémoire
    \begin{lstlisting}
target% mount -t tmpfs none tmp
host$ echo 'none /tmp tmpfs' >> etc/fstab
    \end{lstlisting}
  \end{itemize}
\end{frame}

\subsection{\file{MAKEDEV}}

\begin{frame}[fragile=singleslide]{Utilisation de \cmd{MAKEDEV}}
  \cmd{MAKEDEV} permet d'automatiser  la création des fichiers devices
  de base
  \begin{lstlisting}
host$ cd dev
host$ MAKEDEV std
host$ MAKEDEV console
  \end{lstlisting}
\end{frame}

\subsection{\file{ptms}}

\begin{frame}[fragile=singleslide]{Peudo Terminal Multiplexer}
  \cmd{ptmx} (Peudo  Terminal Multiplexer) Permet  de facilement gérer
  l'allocation des terminaux. (Nécessaire pour Dropbear)
  \begin{lstlisting}
host% mknod dev/ptmx c 5 2
host$ mkdir dev/pts
host$ echo 'none /dev/pts devpts' >> etc/fstab
  \end{lstlisting}
\end{frame}

\subsection{\file{mdev}}

\begin{frame}[fragile=singleslide]{Utilisation de \cmd{mdev}}
  \begin{itemize}
  \item Intégré dans Busybox
  \item Uniquement depuis 2.6, nécessite \file{/sys} compilé et monté
  \item Permet de créer les devices à la volée
  \item Sur  les systèmes  très petits et  où l'utilisation  de device
    dynamique n'est  pas nécessaire, onse passe de  \cmd{mdev} à cause
    des dépendances avec le noyau
  \item Création de \file{/dev} sur un disque mémoire
    \begin{lstlisting}
target% mount -t tmpfs none /dev
    \end{lstlisting}
  \item Initialisation \file{/dev} lors du démarrage
    \begin{lstlisting}
target% mdev -s
    \end{lstlisting}
  \item  Installation  de  \cmd{mdev}  comme \emph{handler}  pour  les
    nouveaux périphériques
    \begin{lstlisting}
target% echo /sbin/mdev > /sys/kernel/uevent_helper 
    \end{lstlisting}
%   \item  Automatisation du processus
%     \begin{lstlisting}
% host$ echo 'none /dev tmpfs' >> etc/fstab
% host$ echo "mdev -s" >> etc/rcS
% host$ echo "echo /sbin/mdev > /sys/kernel/uevent_helper" >> etc/rcS
%     \end{lstlisting}
    \note[item]{Brancher une clef USB pour faire la démonstration}
  \end{itemize}
\end{frame}

\subsection{\file{resolv.conf}}

\begin{frame}[fragile=singleslide]{Résolution DNS}
  \begin{itemize}
  \item Ajout de la résolution DNS
    \begin{lstlisting}
host$ echo nameserver 192.168.1.254 > etc/resolv.conf
target% ping www.google.com
    \end{lstlisting}
  \item  Utiliser la  \emph{glibc}  au lieu  de  la \emph{uclibc}.  Il
    serait    alors    nécessaire    de    configurer    le    fichier
    \file{nsswitch.conf}.   Il  serait   possible  de   chosir  parmis
    différente  back-ends  pour  gérer  les  authentifications  et  le
    réseau.
  \end{itemize}
\end{frame}

\subsection{\file{passwd}}

\begin{frame}[fragile=singleslide]{Ajouts d'utilisateurs}
  \begin{itemize}
  \item Ajout d'utilisateurs  (nécessaire pour beaucoup d'applications
    dont Dropbear)
    \begin{lstlisting}
host$ echo 'root:x:0:0:root:/root:/bin/sh' > etc/passwd
host$ echo 'root:x:0:' > etc/group
    \end{lstlisting}
  \item  \verb'root::0:0:root:/root:/bin/sh'  créerait un  utilisateur
    sans mot de passe
    \note[item]{TODO: Parler de shadow, mkpasswd}
  \end{itemize}
\end{frame}

\subsection{Dropbear}

\begin{frame}[fragile=singleslide]{Dropbear}
  \begin{itemize}
  \item Serveur et client ssh
  \item Procédure classique (ou presque)
    \begin{lstlisting}
host$ wget http://matt.ucc.asn.au/dropbear/releases/dropbear-0.53.tar.bz2
host$ tar xvjf dropbear-0.53.tar.bz2
host$ mkdir build
host$ ../configure --disable-zlib --host=arm-linux --build=i386 --prefix=$(pwd)/../install
host$ make PROGRAMS="dropbear dbclient dropbearkey dropbearconvert scp"
host$ make install
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Dropbear}
  \begin{itemize}
  \item Gestion des clef authorisées
    \begin{lstlisting}
host$ mkdir -p etc/dropbear
host$ mkdir -p root/.ssh
host$ cp ~/.ssh/authorized_keys root/.ssh
    \end{lstlisting}%$
  \item Génération des clef host:
    \begin{lstlisting}
target% dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key
target% dropbearkey -t dss -f /etc/dropbear/dropbear_dss_host_key
target% dropbear -E
host$ echo "ttyS0::respawn:/sbin/dropbear -E" >> etc/inittab
host$ ssh root@target
    \end{lstlisting}
  \end{itemize}
  Dropbear  nécessite un  certain  nombre de  fonctionnalité de  notre
  Linux.  Le faire  fonctionner est  un bon  test de  compatibilité de
  notre système
\end{frame}

\section{Bootstrapper la toolchain}

\begin{frame}[fragile=singleslide]{Compiler le cross-compiler et la libc}
  \begin{itemize}
  \item Le compilateur et la \cmd{libc} se compile ensemble
  \item On peut identifier la toolchain à son triplet:
    \begin{itemize}
    \item \verb+<CPU>-<VENDOR>-<SYSTEM>+
    \item \verb+<SYSTEM> ~ <KERNEL>-<OS>+
    \item \verb+<KERNEL> =+ linux
    \item \verb+<OS>+  est une notion  plus floue: gnu,  ulibc, glibc,
      ulibcgnueabi...
    \end{itemize}
  \item  Pour \cmd{gcc},  on abbrège  souvent le  triplet  en omettant
    \verb+<VENDOR>+
  \item Exemples: 
    \begin{itemize}
    \item ppc85-e8541-linux-gnu % A verfieir
    \item arm9-atmel-linux-ulibceabi % A verifier
    \item sh4-st-unknown: Pas de libc, permet de compiler le noyau
      et u-boot, mais pas d'application user
    \item i586-pc-mingw32msvc: Target windows
    \end{itemize}
  \item Attention, ca n'est pas une science exacte
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler le cross-compiler et la libc}
  \begin{itemize}
  \item 3 étapes: 
    \begin{itemize}
    \item On compile \cmd{arm-unknown-gcc}
    \item On configure le noyau
    \item On  compile la  \cmd{libc} avec \cmd{arm-unknown-gcc}  et le
      noyau préconfiguré, on compile le noyau
    \item On compile \cmd{arm-linux-libc-gcc}
    \end{itemize}
  \item Difficultés :
    \begin{itemize}
    \item Assez complexe
    \item Souvent des problèmes de compatibilité entre les versions
    \end{itemize}
  \end{itemize}
\end{frame}    

\begin{frame}[fragile=singleslide]{Compiler le cross-compiler et la libc}
  Différentes \cmd{libc}:
  \begin{itemize}
  \item glibc (``GNU C Library'', la vénérable)
  \item  eglibc  (``Embedded GNU  C  Library'',  meilleur support  des
    diverses  architectures.  Utilisée  depuis récement  sur  diverses
    distributions ``desktop'')
  \item newlib (utilisée par Cygwin) 
  \item uclibc (très utilisées dans l'embarqué)
  \item  dietlibc  (encore  plus   petite  que  ulibc  destinée  à  la
    compilation statique)
  \item bionic (Android)
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler la toolchain}{Crosstool-NG}
  Crosstool-NG :
  \begin{itemize}
  \item Système automatisant toute la procédure et intégrant les patch
    connu pour rendre compatible certains systèmes
  \item Principalement maintenu par Yann Morin (cocoricco)
  \item Il n'existe pas de paquet, nous devons donc le compiler nous même:
    \begin{lstlisting}
host% apt-get install linux-kernel-headers linux-headers texinfo flax yacc ...
host$ wget http://ymorin.is-a-geek.org/download/crosstool-ng/crosstool-ng-1.10.0.tar.bz2
host$ tar xvzf crosstool-ng-1.10.0.tar.bz2
host$ cd crosstool-ng-1.10.0
host$ ./configure
host$ make 
host% make install
    \end{lstlisting}
  \end{itemize}
\end{frame}
   
\begin{frame}[fragile=singleslide]{Compiler la toolchain}{Crosstool-NG}
  \begin{itemize}
  \item Préparation du répertoire de build
    \begin{lstlisting}
$ mkdir ct-build
$ cd ct-build
$ ct-ng help
    \end{lstlisting}
  \item Partons de l'exemple le plus proche de notre configuration
    \begin{lstlisting}
$ ct-ng list-samples
$ ct-ng arm-unknown-linux-uclibcgnueabi
    \end{lstlisting}
  \item Vérifions que le l'exemple compile
    \begin{lstlisting}
$ ct-ng build
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler la toolchain}{Crosstool-NG}
  \begin{itemize}
  \item Configurons notre chaine de compilation finale
    \begin{lstlisting}
$ ct-ng clean 
$ ct-ng menuconfig
       \end{lstlisting}
     \item Dans la configuration
       \begin{lstlisting}
Prefix directory: /opt
Number of parallel jobs: 3
# Page de man de gcc + documentation du CPU :
... Emit assembly for CPU: arm926ej-s ...
... Tune for CPU: arm926ej-s ...
# Documentation du CPU + man gcc + wikipedia (http://en.wikipedia.org/wiki/ARM_architecture)
... Architecture level: armv5te ...
... Tuple vendor string : sysmic ...
       \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler la toolchain}{Crosstool-NG}
  \begin{itemize}
     \item Compilons
       \begin{lstlisting}
$ chmod 777 /opt
$ ct-ng build
$ ct-ng tarball
       \end{lstlisting}
     \item Testons en statitique
       \begin{lstlisting}[basicstyle=\ttfamily\scriptsize\color{colBasic}]
host$ /opt/arm-unknown-linux-uclibcgnueabi/bin/arm-unknown-linux-uclibcgnueabi-gcc -static -Wall -I. hello.c -o hello-mygcc-static
target$ ./hello-mygcc-static
       \end{lstlisting}
     \item Testons en dynamique
       \begin{lstlisting}[basicstyle=\ttfamily\scriptsize\color{colBasic}]
host$ /opt/arm-unknown-linux-uclibcgnueabi/bin/arm-unknown-linux-uclibcgnueabi-gcc -Wall -I. hello.c -o hello-mygcc
target$ ./hello-mygcc
	\end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler la toolchain}{Crosstool-NG}
  \begin{itemize}
      \item Il  possible (probable) que les bibliothèque  et le format
        de  binaire  ne  soient   pas  compatible  avec  la  toolchain
        existante.    Il  est   alors  nécessaire   de   recopier  les
        bibliothèque  provenant de toolchain  et de  recompiler TOUTES
        les binaires du système
      \item Ajoutons quelques lien symboliques bien pensés
       \begin{lstlisting}[basicstyle=\ttfamily\scriptsize\color{colBasic}]
host$ cd /opt/arm-unknown-linux-uclibcgnueabi/bin
host$ for i in arm-unknown-linux-uclibcgnueabi-*; do 
> ln -s $i arm-linux-${i#arm-unknown-linux-uclibcgnueabi-}; 
> done
	\end{lstlisting}
      \item N'espérez  pas compiler  du premier coup.  Mais autrefois,
        c'était pire!
      \end{itemize}
\end{frame}


\section{Initramfs}

\begin{frame}[fragile=singleslide]{Initramfs}
  \begin{itemize}
  \item Qu'est-ce qu'un initramfs?
  \item Un petit filesystème chargé en mémoire par le bootloader
  \item Successeur de initrd (plus complexe d'utilisation)
  \item Permet déffectuer des actions avant le lancement d'init
  \item Il devrait rester petit et ne s'utiliser que pour continuer le
    boot
  \item  Si  vous  intégrez  busybox  dans  votre  initramfs,  il  est
    préconisé  de  le compiler  en  statique  en  ne gardant  que  les
    composant utiles
  \item  Cas classique:  charger les  modules permettent  d'acceder au
    filesystème:
    \begin{itemize}
    \item M-Sys Disc-On-Chip
    \item Configuration RAID
    \item Configuration réseau pour booter en NFS
    \end{itemize}
  \item Dans notre cas, il n'est pas utile car nous n'avons pas besoin
    de charger de driver particuliers avant le démarrage
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{Initramfs}
  \begin{itemize} 
  \item Création d'un rootfs vraiment minimal:
    \begin{lstlisting}
host$ mkdir initramfs
host$ cd initramfs
host$ mkdir dev
host$ mknod dev/console c 5 1
host% cp .../hello-arm-static init
host$ find . |  cpio -o | gzip > initramfs.gz
    \end{lstlisting}
  \item Comme l'image noyau, l'image initramfs doit être au format u-boot.
    \begin{lstlisting} 
host$ mkimage -A arm -T ramdisk -d initramfs.gz initramfs.gz.img
host$ cp initramfs.gz.img /srv/tftp
uboot> tftp 4000000 initramfs.gz.img
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Initramfs}
  \begin{itemize} 
  \item  On  indique  l'adresse   du  ramfs  en  second  paramètre  de
    \cmd{bootm}. Evidement, le noyau doit être configuré pour utiliser
    le ramfs.
    \begin{lstlisting} 
uboot> setenv autostart no
uboot> tftp 22000000 initramfs.gz.img 
uboot> tftp 21000000 uImage 
uboot> bootm 21000000 22000000 
    \end{lstlisting}
  \end{itemize}
  \note[item]{TODO P1 A verifier, tester, completer}
\end{frame}

\section{Flasher le rootfs}

\begin{frame}[fragile=singleslide]{Création du rootfs}
  Pour créer une image \cmd{jffs2}, vous devez au minimum spécifier le
  répertoire  de source,  l'image de  destination, l'endianness  et le
  padding:
  \begin{lstlisting} 
host$ mkfs.jffs2 -l -p -r nfs-root -o rootfs.jffs2
  \end{lstlisting}
  Afin de  rendre notre  image plus perfomante,  tunons la  taille des
  pages,  supprimons  les  cleanmarkers  (on pourrait  aussi  utiliser
  \verb+-c 0+) et changeons le propriétaires des fichier en root:
  \begin{lstlisting} 
host$ mkfs.jffs2 -l -p -q -n -s 2048 -e 128 -r nfs-root -o rootfs.jffs2
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide]{Recopier le système sur la flash}
  Le  plus  générique pour  recopier  la flash  sur  la  cible est  de
  démarrer Linux par un autre moyen  (NFS ou partition de rescue) et d
  utiliser les outils Linux.
  \begin{itemize} 
  \item Toujours commencer par effacer le contenu précédent (on risque
    sinon des corruptions sur le filesystem)
    \begin{lstlisting}
target% flash_eraseall /dev/mtd1
target% cd /tmp
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Recopier le système sur la flash}
  \begin{itemize} 
  \item Téléchargeons  le rootfs sur  notre cible. Nous  pouvons avoir
    des problèmes  de place pour stoker  cette image.  Il  est dans ce
    cas préférable de  travailler sur NFS (mais ca  n'est pas toujours
    possible).
    \begin{lstlisting} 
target% tftp -g -r rootfs.jffs2
target% flashcp rootfs.jffs2 /dev/mtd1
    \end{lstlisting}
  \item Test. Les devices \verb+mtd*+ et \verb+mtdblock*+ doivent être présents.
    \begin{lstlisting}
target% mkdir /tmp/jffs2
target% mount -t jffs2 /dev/mtdblock1 /tmp/jffs2
    \end{lstlisting} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Recopier le système sur la flash}
  Il est possible d'effectuer cette opération à partir de U-Boot.
  \begin{itemize} 
  \item Nous allons utiliser TFTP sans démarrer dessous. Désactivons l'autostart
    \begin{lstlisting} 
uboot> set autostart no
    \end{lstlisting} 
  \item Toujours effacer la flash avant de flasher
    \begin{lstlisting} 
uboot> nand erase clean 1000000 8800000
    \end{lstlisting} 
  \item On place l'image en mémoire afin de la flasher
    \begin{lstlisting} 
uboot> tftp 21000000 rootfs.arm.jffs2
uboot> nand write 21000000 1000000 5A0000
    \end{lstlisting} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Recopier le noyau sur la flash}
  L'opération est similaire au filesystem. Dans la plupart des cas, on
  place le  noyau à  part sur  une autre partition  de la  flash. Nous
  n'avons alors pas besoin de filesystem:
  \begin{itemize} 
  \item Sous Linux
    \begin{lstlisting}
target% flash_eraseall /dev/mtd0
target% cd /tmp
target% tftp -g -r uImage
target% flashcp uImage /dev/mtd0
    \end{lstlisting}
  \item Sous U-boot
    \begin{lstlisting} 
uboot> tftp 21000000 uImage
uboot> nand erase clean 400000 200000
uboot> nand write 21000000 400000 200000
    \end{lstlisting} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Automatisation}
  Les  options  non utilisées  par  le  noyau  sont passée  au  script
  d'initialisation.   Ajoutons  une   option  permettant   de  flasher
  automatiquement notre cible:
  \begin{lstlisting}
if [ $1 == FLASH ]
  flash_eraseall /dev/mtd0
  flash_eraseall /dev/mtd1
  cd /tmp
  flashcp uImage /dev/mtd0
  flashcp rootfs.jffs2 /dev/mtd1
fi
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide]{Monter le rootfs sur l'hôte}
  L'hôte  ne possèdant  pas  de  flash, nous  devons  la simuler  pour
  pouvoir monter le rootfs:
  \begin{itemize} 
  \item  Chargeons le  module  permettant l'émulation  d'une flash  et
    copions notre image sur la flash virtuelle
    \begin{lstlisting}
host% modprobe mtdram total_size=65536 erase_size=256
host% flashcp rootfs.jffs2 /dev/mtd0
    \end{lstlisting}
  \item  Alternativement, il  est  possible de  directement mapper  un
    fichier sur une flash avec \file{block2mtd}
    \begin{lstlisting}
host% losetup /dev/loop0 rootfs.jffs2
host% modprobe block2mtd block2mtd=/dev/loop0
    \end{lstlisting} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Monter le rootfs sur l'hôte}
  \begin{itemize} 
  \item Chargeons la couche d''emulation par block et le filesystem
    \begin{lstlisting}
host% modprobe mtdblock
host% modprobe jffs2
    \end{lstlisting}
  \item Copie de notre image
    \begin{lstlisting} 
host% mkdir jffs2-mount
host% mount -t jffs2 /dev/mtdblock0 jffs2-mount
    \end{lstlisting} 
  \end{itemize}
  % http://wiki.maemo.org/Modifying_the_root_image
\end{frame}

\note[item]{Est-ce que l'on ne devrait pas placer les chapitre sur u-boot et SAm-BA ici? Je pense que oui}

\section{Simuler}

\begin{frame}[fragile=singleslide]{Qu'est-ce que Qemu?}
  \begin{itemize}
  \item Machine Virtuelle
  \item Comparé à VirtualBox et VMWare:
    \begin{itemize}
    \item Plus polyvalent
    \item ...mais un peu  moins intuitif (possibilite d'utiliser qtemu
      ou qemulator)
    \end{itemize}
  \item Rapide car:
    \begin{itemize}
    \item Utilise la compilation JIT (Just-In-Time)
    \item Utilise des extention du processeur pour gérer les
      addresses virtuelle (Module KVM)
      \begin{lstlisting}
host% apt-get install qemu-kvm-extras
      \end{lstlisting}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Qu'est-ce que Qemu?}
  Emule:
  \begin{itemize}
  \item Simplement un jeux d'instruction 
    \begin{itemize}
    \item Toutes les grandes architectures sont supportée
    \item  Les  appels  système  sont  alors bindéz  vers  les  appels
      systèmes de l'hote
      \begin{lstlisting}
host% qemu-arm ./hello-arm-static
host% qemu-arm -L ../arm-linux-uclibceabi/ ./hello-arm-debug
      \end{lstlisting}
    \item Utilisé par Scratchbox
      \begin{itemize}
      \item Scratchbox crée un chroot et utiliser fakechroot
      \item Qemu  doit être compilé  en static pour être  utilisé avec
        fakechroot (sombre histoire de libld) % A vérifier
      \end{itemize}
    \item Ne permet pas d'avoir un périphérique virtuel
    \end{itemize}
  \item Un système
    \begin{itemize}
    \item Il est possible  d'émuler des periphérique non existants sur
      PC
    \item  Il  est  possible  avec  un peu  d'effort  de  simuler  des
      périphériques spéciaux.
    \item Simulation de système complets. QA
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Qu'est-ce que Qemu?}
  \begin{itemize}
  \item Le  port série de l'AT91  n'est pas présent dans  la liste des
    périphériques de Qemu
  \item On va donc simuler une autre board
  \end{itemize}
  \begin{lstlisting}[basicstyle=\ttfamily\scriptsize\color{colBasic}]
host$ wget http://wiki.qemu.org/download/arm-test-0.2.tar.gz
host$ tar xvzf arm-test-0.2.tar.gz
host$ qemu-system-arm -M integrator -cpu arm926 -m 16 -kernel zImage.integrator -initrd arm_root.img
host$ qemu-system-arm -M integrator -cpu arm926 -m 16 -kernel zImage.integrator -initrd arm_root.img -nographic -append "console=ttyAMA0"
  \end{lstlisting}
\end{frame}

% Acceder aux disque Qemu sans  démarrer Qemu: Before you can use this
% command you  need to  have the NBD  kernel module  loaded ('modprobe
% nbd') then you  can map the virtual harddisk file  to the nbd device
% ('qemu-nbd -vc/dev/nbd0  HD image.qcow') this will work  with any HD
% image format supported by qemu.   This will create a device for each
% partition in the virtual hard disk  file. You can then mount the the
% partions  like 'sudo mount  /dev/nbd0p1 /mnt'  When done  you should
% unmount ('umount  /mnt') and  disconnect the HD  image from  the nbd
% device ('qemu-nbd -d /dev/nbd0') -> On peut aussi utiliser xmount

% Dimensionner une syst`eme Linux embarqué
%    \item PC ou autre?
%    \item Linux ou autre?
%    \item Voir livre de Pierre Ficheux

% TODO: Compiler X et Qt pour Integrator

\section{Automatisation}

\begin{frame}[fragile=singleslide]{Automatisation}{Buildroot}
  \begin{itemize}
  \item But: créer un filesystem root
  \item Utilisation de Kconfig
  \item Thomas Petazzoni
  \item Permet d'automatiser la création  de la toolchain, du noyau,
    de busybox et d'environ 300 outils
    \begin{itemize}
    \item serveurs http, ftp, ssh, etc..
    \item outils réseau, wireless, bluetooth, etc...
    \item Serveur X, gtk
    \end{itemize}
  \item Architecture assez propre
  \item Extention relativement simple ou nous retrouvons les commandes
    utilisée pour compiler des programmes tierces
  \item C'est un peu l'extention de Busybox
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Automatisation}{Buildroot}
  \begin{itemize}
  \item Récupération des sources
    \begin{lstlisting}
host$ wget http://buildroot.uclibc.org/downloads/buildroot-2010.11.tar.bz2
host$ tar xvf buildroot-2010.11.tar.bz2
host$ cd buildroot-2010.11
    \end{lstlisting} 
  \item  Utilisation  d'une configuraiton  pré-établie  comme base  de
    configuration
    \begin{lstlisting}
host$ make usb-a9260_defconfig
host$ make menuconfig
host$ make linux26-menuconfig
host$ make uclibc-menuconfig
host$ make busybox-menuconfig
host$ make all
    \end{lstlisting}
  \item Documentation: \url{http://buildroot.uclibc.org/buildroot.html}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Automatisation}{OpenEmbedded}
  \begin{itemize}
  \item But: créer une distribution type Debian
  \item Gère un système de paquets
  \item Assez lourd à la configuration
  \item Tres lourd de créer une nouvelle cible
  \item Beaucoup de paquets sont deja préparés (~1800)
    \begin{itemize}
    \item .. Principalement, toute la suite Gtk Opie
    \end{itemize}
%  \item remplacé par Buildroot et Scratchbox 
%   \note[item]{Tout ici: \url{http://www.at91.com/linux4sam/bin/view/Linux4SAM/OpenEmbeddedAngstromBuild}}
%   \note[item]{Résultat ici: \url{ftp://www.at91.com/pub/demo/linux4sam_2.0/linux4sam-angstrom-at91sam9260ek.zip}}
%   \item  Récupératon d'une version d'OpenEmbedded ppackagə pour notre architecture
%   \begin{lstlisting}
% wget ftp://ftp.linux4sam.org/pub/oe/linux4sam_x.y/oe_at91sam.tgz
% tar xvzf oe_at91sam.tgz

% vim oe_at91sam/conf/local.conf
% source ./oe_env.sh
% apt-get install bitbake
% bitbake base-image
% bitbake console-at91sam9-image
% bitbake x11-at91sam9-image
%   \end{lstlisting}
    \note[item]{TODO P4: Faire fonctionne OpenEmbedded}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Automatisation}{Strachbox}
  \begin{itemize}
  \item but: créer une distribution type Debian
  \item Utilisé  par Meego (Nokia,  intel, Renault, etc..)  et Android
    (en cours)
  \item packagé: \verb+apt-get install scratchbox2+
  \item Coquille vide
    \begin{itemize}
    \item On peut installer l'environement de Maemo ou de Android
    \end{itemize}
  \item Basé sur un fonctionnement hybrid avec qemu
    \begin{itemize}
    \item On compile avec le  cross-compiler mais le reste est executé
      avec qemu ou en ssh sur la cible
    \item S'utilie comme un environement de compilation normal
    \item Rend la cross-compilation transparente
    \item Fonctionne pour ARM and  x86 targets (PowerPC, MIPS and CRIS
      targets are experimental)
    \item  Permet de  conpiler certains  packets ne  peuvent  pas etre
      cross-compilé (Notablement Python)
    \item Depend du bon fonctionnement de qemu
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Qemu et Scratchbox}
  \begin{itemize} 
  \item Installation
    \begin{lstlisting}
host% apt-get install scratchbox2
host$ mkdir scratchbox
host$ cd scratchbox
    \end{lstlisting}
  \item Initialisation de l'environement. Nous utilisons qemu-arm pour
    lancer nos binaire cibles et arm-linux-gcc comme compilateur
    \begin{lstlisting} 
host$ sb2-init -c qemu-arm -n A926 arm-linux-gcc
    \end{lstlisting}
  \item Démarrage de l'environement 
    \begin{lstlisting} 
host$ sb2
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Qemu et Scratchbox}
  \begin{itemize} 
  \item La cross-compilation est transparente
    \begin{lstlisting} 
qemu$ gcc hello.c -static -o hello-sb2-static
qemu$ file hello-sb2-static
qemu$ ./hello-sb2-static
qemu$ gcc hello.c -o hello-sb2
qemu$ file hello-sb2
    \end{lstlisting}
  \item Comme  sur la cible,  nous avons besoin que  les bibliothèques
    soit bien configurées dans notre environement
    \begin{lstlisting} 
qemu$ cp -a /opt/arm-unknown-linux-uclibcgnueabi/arm-unknown-linux-uclibcgnueabi/sysroot/lib .
qemu$ ./hello-sb2
    \end{lstlisting} 
  \end{itemize} 
\end{frame}




